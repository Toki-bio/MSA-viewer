<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Qwen MSA Viewer</title>
  <style>
    :root {
      --nameLen: 20;
    }
    body {
      font-family: 'Courier New', monospace;
      font-size: 13px;
      margin: 0;
      padding: 0;
      background: white;
      color: black;
      height: 100vh;
      display: flex;
      flex-direction: column;
    }
    #dropZone {
      border: 2px dashed #1a2129;
      border-radius: 4px;
      padding: 8px;
      text-align: center;
      color: #555;
      font-size: 13px;
      background: #f0f8ff;
      display: flex;
      align-items: center;
      justify-content: center;
      min-height: 40px;
    }
    #dropZone:hover {
      border-color: #004c99;
      background: #e0f0ff;
    }
    #controls {
      position: sticky;
      top: 0;
      background: white;
      padding: 6px 8px;
      border-bottom: 1px solid #ddd;
      z-index: 100;
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
      gap: 6px;
      font-size: 13px;
    }
    .menu-section {
      margin-bottom: 4px;
    }
    .section-header {
      font-size: 14px;
      margin: 4px 0;
      color: #2c3e50;
      font-weight: bold;
    }
    /* Button Groups */
    .button-group {
      display: flex;
      flex-wrap: wrap;
      gap: 4px;
      align-items: center;
      font-size: 12px;
      border: 1px solid #eee;
      border-radius: 4px;
      padding: 2px;
      background: #fafafa;
    }
    .button-spacer {
      width: 1px;
      height: 16px;
      background: #ccc;
      margin: 0 4px;
    }
    /* Buttons */
    button {
      padding: 2px 6px;
      margin: 1px;
      font-size: 12px;
      border: 1px solid #ccc;
      border-radius: 3px;
      background: white;
      cursor: pointer;
    }
    button:hover {
      background: #e6f3ff;
    }
    /* Control Groups */
    .control-group {
      display: block;
      margin: 2px 0;
    }
    .slider-container {
      margin: 2px 0;
      display: flex;
      align-items: center;
      gap: 6px;
      height: 22px;
      line-height: 22px;
    }
    .display-slider-row {
      min-width: 340px;
      display: grid;
      grid-template-columns: 70px 130px 45px auto;
      gap: 8px;
      align-items: center;
    }
    .slider-label {
      width: 70px;
      display: inline-block;
      text-align: right;
      font-weight: normal;
    }
    /* === SHADING SLIDERS (Black, Dark, Light) - Solid Rectangles === */
    input[type="range"].shading-slider {
      -webkit-appearance: none;
      width: 130px;
      height: 22px;
      background: transparent;
      outline: none;
    }
    input[type="range"].shading-slider::-webkit-slider-runnable-track {
      height: 8px;
      border-radius: 4px;
      cursor: pointer;
    }
    #blackSlider::-webkit-slider-runnable-track { background: #000; }
    #darkSlider::-webkit-slider-runnable-track { background: #555; }
    #lightSlider::-webkit-slider-runnable-track { background: #ccc; }
    input[type="range"].shading-slider::-webkit-slider-thumb {
      -webkit-appearance: none;
      height: 14px;
      width: 8px;
      border: 2px solid black;
      border-radius: 2px;
      margin-top: -3px;
      cursor: pointer;
      background: white;
    }
    /* === OTHER SLIDERS (Name Len, Zoom, Block Size) === */
    input[type="range"].normal-slider {
      -webkit-appearance: none;
      width: 130px;
      height: 14px;
      background: transparent;
      outline: none;
    }
    input[type="range"].normal-slider::-webkit-slider-runnable-track {
      height: 7px;
      border-radius: 7px;
      background: #888;
    }
    input[type="range"].normal-slider::-webkit-slider-thumb {
      -webkit-appearance: none;
      width: 8px;
      height: 14px;
      border: 2px solid black;
      border-radius: 2px;
      background: white;
      cursor: pointer;
      margin-top: -3px;
    }
    input[type="number"] {
      width: 38px;
      height: 22px;
      padding: 0;
      text-align: center;
    }
    /* Block styling */
    .block-block {
      margin-bottom: 8px;
    }
    .block-sep {
      font-weight: bold;
      color: #666;
      text-align: center;
      margin: 4px 0;
      padding: 2px 0;
      background: #f0f0f0;
      border-radius: 3px;
    }
    #alignmentContainer {
      flex: 1;
      overflow-x: auto;
      overflow-y: auto;
      background: white;
      font-family: 'Courier New', monospace;
      line-height: 1.0;
      white-space: pre;
      border: 1px solid #ddd;
      font-size: 13px;
      transition: font-size 0.1s;
    }
    .seq-line {
      display: flex;
      font-family: 'Courier New', monospace;
      line-height: 1.0;
      margin: 0;
      padding: 0;
      white-space: nowrap;
    }
    .seq-name {
      flex: 0 0 auto;
      min-width: calc(var(--nameLen) * 0.8em);
      width: calc(var(--nameLen) * 0.8em);
      max-width: calc(var(--nameLen) * 0.8em);
      text-align: left;
      padding: 0;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
      font-weight: bold;
      color: #333;
      background: white;
    }
    .seq-data {
      flex: 1;
      display: inline-block;
      white-space: nowrap;
      margin: 0;
      padding: 0;
      line-height: 1.0;
    }
    /* GeneDoc-inspired coloring */
    .black { background-color: #000 !important; color: white; }
    .dark { background-color: #555; color: white; }
    .light { background-color: #ccc; color: black; }
    .gap { background-color: white !important; color: #888 !important; }
    .other { background-color: white; color: black; }
    .ambiguous { color: #0000AA; font-weight: bold; }
    .artifact {
      color: red !important;
      background-color: #ffe6e6 !important;
      font-weight: bold !important;
    }
    /* ‚úÖ SELECTION: Highlight name only */
    .selected .seq-name {
      background-color: #ffebcd !important;
      color: #000 !important;
      font-weight: bold;
    }
    /* Column selection */
    .column-selected {
      background-color: #e6ffe6 !important;
    }
    /* Consensus line */
    .consensus-line {
      border-top: 1px solid #ccc;
      margin-top: 4px;
      font-style: normal;
      color: #555;
      font-weight: bold;
    }
    .consensus-line .seq-name {
      color: #555;
      font-weight: bold;
    }
    .consensus-line .seq-data span {
      opacity: 0.9;
      background-color: transparent !important;
      color: #555;
    }
    /* Error message */
    .error-message {
      color: red;
      font-weight: bold;
      padding: 10px;
      background: #ffe6e6;
      border: 1px solid #ff8080;
      margin: 5px;
      border-radius: 4px;
    }
    /* Search highlight */
    .search-hit {
      background-color: yellow !important;
      color: black !important;
      font-weight: bold;
    }
    /* Tooltip */
    .tooltip {
      position: absolute;
      background: white;
      color: black;
      font-size: 12px;
      padding: 2px 6px;
      border-radius: 3px;
      white-space: nowrap;
      z-index: 200;
      display: none;
      border: 1px solid #ccc;
    }
    /* Info Modal */
    .modal {
      display: none;
      position: fixed;
      z-index: 1000;
      left: 0;
      top: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(0,0,0,0.5);
    }
    .modal-content {
      background-color: #fefefe;
      margin: 5% auto;
      padding: 20px;
      border: 1px solid #888;
      width: 80%;
      max-width: 800px;
      max-height: 80vh;
      overflow-y: auto;
      border-radius: 8px;
      font-family: Arial, sans-serif;
      line-height: 1.6;
    }
    .close {
      color: #aaa;
      float: right;
      font-size: 28px;
      font-weight: bold;
      cursor: pointer;
    }
    .close:hover,
    .close:focus {
      color: black;
      text-decoration: none;
    }
    .modal h2, .modal h3 {
      color: #2c3e50;
    }
    .modal ul {
      margin: 10px 0;
      padding-left: 20px;
    }
  </style>
</head>
<body>
  <div id="controls">
    <h2 style="grid-column: 1/-1; text-align: center; margin: 2px 0; font-size: 16px;">Qwen MSA Viewer</h2>
    <!-- Quick Usability Tips -->
    <div style="grid-column: 1/-1; text-align: center; font-size: 12px; color: #2980b9; font-weight: bold; background: #ecf0f1; padding: 4px; border-radius: 4px;">
      üîç Hover: Seq & Pos | Ctrl+click: Select Seqs | Ctrl+Alt+click: Select Cols | Drag: Range Select
    </div>
    <div class="menu-section" style="grid-column: 1/-1; display: flex; gap: 6px; align-items: start;">
      <div id="dropZone" style="flex: 0 0 180px; padding: 6px;">üìÅ Drop FASTA</div>
      <textarea id="fastaInput" placeholder=">seq1&#13;&#10;ATGCGGCTA..." style="flex: 1; height: 60px; font-size: 12px; padding: 4px;"></textarea>
      <button onclick="parseAndRender(false)" style="height: 60px; font-size: 13px;">Load</button>
    </div>
    <div class="menu-section">
      <div class="section-header">Shade</div>
      <div class="control-group">
        <div class="slider-container">
          <span class="slider-label">Black ‚â•</span>
          <input type="range" id="blackSlider" class="shading-slider" min="50" max="100" value="90" oninput="updateLabel('blackVal', this.value); validateThresholds(); debounceRender()">
          <input type="number" id="blackInput" min="50" max="100" value="90" oninput="document.getElementById('blackSlider').value = this.value; updateLabel('blackVal', this.value); validateThresholds(); debounceRender()">
          <span id="blackVal">90</span>%
        </div>
        <div class="slider-container">
          <span class="slider-label">Dark ‚â•</span>
          <input type="range" id="darkSlider" class="shading-slider" min="30" max="90" value="70" oninput="updateLabel('darkVal', this.value); validateThresholds(); debounceRender()">
          <input type="number" id="darkInput" min="30" max="90" value="70" oninput="document.getElementById('darkSlider').value = this.value; updateLabel('darkVal', this.value); validateThresholds(); debounceRender()">
          <span id="darkVal">70</span>%
        </div>
        <div class="slider-container">
          <span class="slider-label">Light ‚â•</span>
          <input type="range" id="lightSlider" class="shading-slider" min="10" max="80" value="50" oninput="updateLabel('lightVal', this.value); validateThresholds(); debounceRender()">
          <input type="number" id="lightInput" min="10" max="80" value="50" oninput="document.getElementById('lightSlider').value = this.value; updateLabel('lightVal', this.value); validateThresholds(); debounceRender()">
          <span id="lightVal">50</span>%
        </div>
        <div class="slider-container">
          <span class="slider-label">Enable</span>
          <label class="shade-mode-label">
            <input type="checkbox" id="enableBlack" checked onchange="debounceRender()"> Black
          </label>
          <label class="shade-mode-label">
            <input type="checkbox" id="enableDark" checked onchange="debounceRender()"> Dark
          </label>
          <label class="shade-mode-label">
            <input type="checkbox" id="enableLight" checked onchange="debounceRender()"> Light
          </label>
        </div>
        <div class="slider-container">
          <span class="slider-label">Shade By</span>
          <label class="shade-mode-label">
            <input type="radio" name="shadeMode" value="nongap" onchange="onShadeModeChange()"> Non-Gap
          </label>
          <label class="shade-mode-label">
            <input type="radio" name="shadeMode" value="all" checked onchange="onShadeModeChange()"> All
          </label>
        </div>
      </div>
    </div>
    <div class="menu-section">
      <div class="section-header">Display</div>
      <div class="control-group">
        <div class="slider-container display-slider-row">
          <span class="slider-label">Name Len</span>
          <input type="range" id="nameLengthSlider" class="normal-slider" min="5" max="100" value="20" oninput="updateLabel('nameLengthVal', this.value); document.getElementById('nameLengthInput').value = this.value; debounceRender()">
          <input type="number" id="nameLengthInput" min="5" max="100" value="20" oninput="document.getElementById('nameLengthSlider').value = this.value; updateLabel('nameLengthVal', this.value); debounceRender()">
          <span id="nameLengthVal">20</span>
        </div>
        <div class="slider-container display-slider-row">
          <span class="slider-label">Zoom</span>
          <input type="range" id="zoomSlider" class="normal-slider" min="50" max="200" value="100" oninput="setZoom(this.value)">
          <input type="number" id="zoomInput" min="50" max="200" value="100" oninput="document.getElementById('zoomSlider').value = this.value; setZoom(this.value)">
          <span><span id="zoomVal">100</span>%</span>
        </div>
        <div class="slider-container display-slider-row" id="blockSizeContainer">
          <span class="slider-label">Block Size</span>
          <input type="range" id="blockSizeSlider" class="normal-slider" min="40" max="200" value="80" oninput="updateLabel('blockSizeVal', this.value); debounceRender()">
          <input type="number" id="blockSizeInput" min="40" max="200" value="80" oninput="document.getElementById('blockSizeSlider').value = this.value; updateLabel('blockSizeVal', this.value); debounceRender()">
          <span id="blockSizeVal">80</span>
        </div>
        <div class="slider-container">
          <input type="radio" id="modeSingle" name="mode" value="single" onchange="onModeChange()">
          <label for="modeSingle">Full</label>
          <input type="radio" id="modeBlocks" name="mode" value="blocks" onchange="onModeChange()" checked>
          <label for="modeBlocks">Block</label>
        </div>
      </div>
    </div>
    <div class="menu-section">
      <div class="section-header">Consensus</div>
      <div class="control-group">
        <div class="slider-container">
          <span class="slider-label">Threshold</span>
          <input type="range" id="consensusThreshold" class="normal-slider" min="50" max="100" value="70" oninput="updateLabel('consensusThresholdVal', this.value); debounceRender()">
          <input type="number" id="consensusThresholdInput" min="50" max="100" value="70" oninput="document.getElementById('consensusThreshold').value = this.value; updateLabel('consensusThresholdVal', this.value); debounceRender()">
          <span id="consensusThresholdVal">70</span>%
        </div>
        <div class="slider-container">
          <span class="slider-label">Type</span>
          <label class="shade-mode-label">
            <input type="radio" name="consensusType" value="normal" checked onchange="debounceRender()"> Normal
          </label>
          <label class="shade-mode-label">
            <input type="radio" name="consensusType" value="ambiguous" onchange="debounceRender()"> Ambiguous
          </label>
        </div>
        <div class="slider-container">
          <input type="checkbox" id="showConsensus" checked onchange="debounceRender()">
          <label for="showConsensus" style="font-size: 12px;">Show Consensus</label>
        </div>
        <div class="slider-container">
          <span class="slider-label">Position</span>
          <label class="shade-mode-label">
            <input type="radio" name="consensusPosition" value="top" onchange="debounceRender()"> Top
          </label>
          <label class="shade-mode-label">
            <input type="radio" name="consensusPosition" value="bottom" onchange="debounceRender()" checked> Bottom
          </label>
        </div>
        <div class="slider-container">
          <button onclick="copyConsensus()" style="padding: 2px 6px; font-size: 12px;">Copy Consensus</button>
        </div>
        <div class="slider-container">
          <button onclick="copySelectedConsensus()" style="padding: 2px 6px; font-size: 12px;">Copy Sel Consensus</button>
        </div>
      </div>
    </div>
    <div class="menu-section">
      <div class="section-header">Search</div>
      <div class="control-group">
        <div class="slider-container">
          <input type="text" id="searchInput" placeholder="Enter motif..." style="width: 130px; height: 22px; padding: 2px; font-size: 12px;">
          <input type="color" id="searchColor" value="#FFFF00" style="width: 30px; height: 22px; padding: 0;">
          <button onclick="searchMotif()" style="padding: 2px 6px; font-size: 12px;">Find</button>
          <button onclick="clearLastSearch()" style="padding: 2px 6px; font-size: 12px;">Clear Last</button>
          <button onclick="clearAllSearches()" style="padding: 2px 6px; font-size: 12px;">Clear All</button>
        </div>
      </div>
    </div>
    <div class="menu-section" style="grid-column: 1/-1;">
      <div class="section-header">Actions</div>
      <!-- Grouped Buttons -->
      <div class="button-group">
        <button onclick="reverseComplementSelected()">RevComp</button>
        <div class="button-spacer"></div>
        <button onclick="copySelected()">Copy Sel</button>
        <button onclick="deleteSelected()">Delete Sel</button>
        <button onclick="undoDelete()">Undo</button>
        <div class="button-spacer"></div>
        <button onclick="selectAllSequences()">Select All</button>
        <div class="button-spacer"></div>
        <button onclick="copySelectedColumns()">Copy Cols</button>
        <button onclick="deleteSelectedColumns()">Delete Cols</button>
        <div class="button-spacer"></div>
        <button onclick="savePreset()">Save Preset</button>
        <button onclick="loadPreset()">Load Preset</button>
        <div class="button-spacer"></div>
        <button onclick="openInfoModal()">Program Info</button>
        <button id="minimizeBtn" onclick="minimizeMenu()">Hide menu</button>
      </div>
    </div>
    <!-- Keyboard hints -->
    <div style="grid-column: 1/-1; text-align: right; font-size: 12px; color: #555;">
      <span style="white-space: nowrap;">Ctrl+click: select seqs</span> |
      <span style="white-space: nowrap;">Shift+click: range</span> |
      <span style="white-space: nowrap;">Ctrl+Alt+click: select cols</span>
    </div>
    <!-- Filename -->
    <div id="filenameInfo" style="grid-column: 1/-1; padding: 2px 8px; font-size: 12px; color: #555; background: #f0f0f0; text-align: center;">Source: Clipboard</div>
  </div>
  <!-- Minimize bar -->
  <div id="minimizeBar" onclick="expandMenu()"></div>
  <!-- Tooltip -->
  <div id="tooltip" class="tooltip"></div>
  <!-- Info Modal -->
  <div id="infoModal" class="modal">
    <div class="modal-content">
      <span class="close" onclick="closeInfoModal()">&times;</span>
      <h2>Qwen MSA Viewer</h2>
      <p>A fast, interactive, and portable Multiple Sequence Alignment viewer.</p>
      <h3>Features</h3>
      <ul>
        <li><strong>Load FASTA:</strong> Drag & drop a file or paste text.</li>
        <li><strong>GeneDoc Coloring:</strong> Visualize conserved regions with adjustable thresholds (Black, Dark, Light).</li>
        <li><strong>Consensus Sequence:</strong> Generate and copy consensus with normal or ambiguous base codes.</li>
        <li><strong>Sequence Selection:</strong> Click, Ctrl+Click, or Shift+Click to select sequences. Perform actions like Reverse Complement, Copy, or Delete.</li>
        <li><strong>Column Selection:</strong> Use Ctrl+Alt+Click to select entire columns. Copy or delete selected columns.</li>
        <li><strong>Search:</strong> Find motifs with custom highlight colors. Clear individual or all searches.</li>
        <li><strong>Undo:</strong> Recover deleted sequences or columns.</li>
        <li><strong>Preset Management:</strong> Save and load your display settings.</li>
      </ul>
      <h3>Quick Tips</h3>
      <ul>
        <li>Hover over a nucleotide to see the sequence name and its <strong>gapless position</strong> (e.g., the 1st, 2nd, 3rd nucleotide in the gene).</li>
        <li>Use the "Block" mode for long alignments to improve readability.</li>
        <li>The "Hide menu" button maximizes the viewing area. Hover near the top to restore it.</li>
      </ul>
      <h3>Controls</h3>
      <p><strong>Shade:</strong> Adjust conservation thresholds and enable/disable shading levels.</p>
      <p><strong>Display:</strong> Change sequence name length, zoom level, and block size.</p>
      <p><strong>Consensus:</strong> Set the frequency threshold for consensus base calling.</p>
      <p><strong>Search:</strong> Enter a motif and choose a highlight color.</p>
      <p><strong>Actions:</strong> All sequence and column manipulation tools are here.</p>
    </div>
  </div>
  <div id="alignmentContainer">Alignment will appear here</div>
  <script>
    let seqs = [];
    let selectedRows = new Set();
    let selectedColumns = new Set();
    let lastSelectedIndex = null;
    let consensusSeq = '';
    let deletedHistory = [];
    let currentFilename = '';
    // Search: Track multiple motifs
    let searchHistory = [];
    // Continuous selection
    let isDragging = false;
    let dragStartRow = null;
    let dragStartCol = null;
    // Minimize bar
    const minimizeBar = document.getElementById('minimizeBar');
    minimizeBar.style.cssText = 'height:20px;background:#333;position:sticky;top:0;width:100%;z-index:99;cursor:pointer;display:none';
    const minimizeBarContent = document.createElement('div');
    minimizeBarContent.id = 'minimizeBarContent';
    minimizeBarContent.style.cssText = 'height:100%;display:flex;flex-direction:column;align-items:center;justify-content:center;color:white;font-size:12px;cursor:pointer;padding:4px;';
    minimizeBar.appendChild(minimizeBarContent);
    minimizeBar.onmouseover = () => {
      minimizeBar.style.height = '200px';
      minimizeBarContent.innerHTML = '<div>Restore Menu (or click)</div>';
      const displaySection = document.querySelector('.menu-section:nth-child(3)');
      if (displaySection) {
        const clonedDisplay = displaySection.cloneNode(true);
        clonedDisplay.querySelectorAll('input[type="range"], input[type="number"]').forEach(input => {
          input.id = input.id + 'Clone';
          input.addEventListener('input', (e) => {
            const originalId = input.id.replace('Clone', '');
            const original = document.getElementById(originalId);
            if (original) original.value = e.target.value;
            if (input.type === 'range') {
              const labelId = originalId.replace('Slider', 'Val');
              updateLabel(labelId, e.target.value);
              const inputId = originalId.replace('Slider', 'Input');
              document.getElementById(inputId).value = e.target.value;
            } else if (input.type === 'number') {
              const sliderId = originalId.replace('Input', 'Slider');
              document.getElementById(sliderId).value = e.target.value;
              const labelId = originalId.replace('Input', 'Val');
              updateLabel(labelId, e.target.value);
            }
            if (originalId.includes('zoom')) setZoom(e.target.value);
            debounceRender();
          });
        });
        clonedDisplay.querySelectorAll('input[type="radio"]').forEach(radio => {
          radio.name = radio.name + 'Clone';
          radio.addEventListener('change', (e) => {
            const original = document.querySelector(`input[name="${radio.name.replace('Clone','')}"][value="${radio.value}"]`);
            if (original) original.checked = radio.checked;
            onModeChange();
          });
        });
        minimizeBarContent.appendChild(clonedDisplay);
      }
    };
    minimizeBar.onmouseout = () => {
      minimizeBar.style.height = '20px';
      minimizeBarContent.innerHTML = '';
    };
    // Drag & Drop
    const dropZone = document.getElementById('dropZone');
    dropZone.addEventListener('dragover', (e) => {
      e.preventDefault();
      dropZone.style.borderColor = '#004c99';
    });
    dropZone.addEventListener('dragleave', () => {
      dropZone.style.borderColor = '#1a2129';
    });
    dropZone.addEventListener('drop', (e) => {
      e.preventDefault();
      dropZone.style.borderColor = '#1a2129';
      const file = e.dataTransfer.files[0];
      if (!file) return;
      currentFilename = file.name;
      const reader = new FileReader();
      reader.onload = function(e) {
        document.getElementById('fastaInput').value = e.target.result;
        parseAndRender(true);
      };
      reader.onerror = () => {
        document.getElementById('alignmentContainer').innerHTML = '<div class="error-message">‚ùå Error reading file.</div>';
      };
      reader.readAsText(file);
    });
    function updateLabel(id, value) {
      document.getElementById(id).textContent = value;
    }
    // Helper function to calculate gapless positions for a sequence
    function calculateGaplessPositions(sequence) {
      const positions = [];
      let gaplessCount = 0;
      for (let i = 0; i < sequence.length; i++) {
        const char = sequence[i];
        if (char !== '-' && char !== '.') {
          gaplessCount++;
        }
        positions.push(gaplessCount);
      }
      return positions;
    }
    function parseFasta(text) {
      const lines = text.trim().split(/\r?\n/);
      const seqs = [];
      let seq = '', header = '';
      try {
        for (let line of lines) {
          line = line.trim();
          if (!line) continue;
          if (line.startsWith('>')) {
            if (seq) {
              const cleanHeader = header.replace(/^>/, '').trim();
              const displayHeader = cleanHeader.split(' ')[0] || 'unnamed';
              const processedSeq = seq.toUpperCase().replace(/[^ACGTUNRYMKSWHBVD\.\-]/g, 'N');
              const gaplessPositions = calculateGaplessPositions(processedSeq);
              seqs.push({
                header: displayHeader,
                fullHeader: cleanHeader,
                seq: processedSeq,
                gaplessPositions: gaplessPositions
              });
              seq = '';
            }
            header = line;
          } else {
            seq += line.replace(/[^A-Za-z\.\-]/g, '');
          }
        }
        if (header && seq) {
          const cleanHeader = header.replace(/^>/, '').trim();
          const displayHeader = cleanHeader.split(' ')[0] || 'unnamed';
          const processedSeq = seq.toUpperCase().replace(/[^ACGTUNRYMKSWHBVD\.\-]/g, 'N');
          const gaplessPositions = calculateGaplessPositions(processedSeq);
          seqs.push({
            header: displayHeader,
            fullHeader: cleanHeader,
            seq: processedSeq,
            gaplessPositions: gaplessPositions
          });
        }
      } catch (err) {
        console.error('Error in parseFasta:', err);
        return null;
      }
      return seqs.length ? seqs : null;
    }
    function renderAlignment() {
      const container = document.getElementById('alignmentContainer');
      if (!seqs || seqs.length === 0) {
        container.innerHTML = '<div class="error-message">‚ùå No valid sequences found.</div>';
        return;
      }
      container.innerHTML = '';
      const nameLen = Math.min(parseInt(document.getElementById('nameLengthSlider').value), Math.max(...seqs.map(s => s.header.length), 5));
      document.getElementById('nameLengthSlider').max = Math.max(...seqs.map(s => s.header.length), 5);
      document.getElementById('nameLengthInput').max = Math.max(...seqs.map(s => s.header.length), 5);
      document.getElementById('nameLengthVal').textContent = nameLen;
      document.documentElement.style.setProperty('--nameLen', nameLen);
      const useBlocks = document.getElementById('modeBlocks').checked;
      const blockWidth = parseInt(document.getElementById('blockSizeSlider').value);
      const len = Math.max(...seqs.map(s => s.seq.length));
      const blackThresh = parseInt(document.getElementById('blackSlider').value) / 100;
      const darkThresh = parseInt(document.getElementById('darkSlider').value) / 100;
      const lightThresh = parseInt(document.getElementById('lightSlider').value) / 100;
      const enableBlack = document.getElementById('enableBlack').checked;
      const enableDark = document.getElementById('enableDark').checked;
      const enableLight = document.getElementById('enableLight').checked;
      const standard = new Set(['A', 'C', 'G', 'T', 'U', 'N', '-', '.']);
      const ambiguous = new Set(['R','Y','M','K','S','W','H','B','V','D']);
      // IUPAC ambiguous code mapping for ties
      const ambiguousMap = {
        'A,G': 'R', 'G,A': 'R',
        'C,T': 'Y', 'T,C': 'Y',
        'A,C': 'M', 'C,A': 'M',
        'G,T': 'K', 'T,G': 'K',
        'C,G': 'S', 'G,C': 'S',
        'A,T': 'W', 'T,A': 'W',
        'A,C,T': 'H', 'A,T,C': 'H', 'C,A,T': 'H', 'C,T,A': 'H', 'T,A,C': 'H', 'T,C,A': 'H',
        'G,C,T': 'B', 'G,T,C': 'B', 'C,G,T': 'B', 'C,T,G': 'B', 'T,G,C': 'B', 'T,C,G': 'B',
        'A,G,T': 'D', 'A,T,G': 'D', 'G,A,T': 'D', 'G,T,A': 'D', 'T,A,G': 'D', 'T,G,A': 'D',
        'A,C,G': 'V', 'A,G,C': 'V', 'C,A,G': 'V', 'C,G,A': 'V', 'G,A,C': 'V', 'G,C,A': 'V'
      };
      // === CONSENSUS ===
      const showConsensus = document.getElementById('showConsensus').checked;
      const consType = document.querySelector('input[name="consensusType"]:checked').value;
      const threshold = parseInt(document.getElementById('consensusThreshold').value) / 100;
      let consensus = [];
      if (showConsensus) {
        for (let pos = 0; pos < len; pos++) {
          const col = seqs.map(s => s.seq[pos] || '-');
          const nonGapCol = col.filter(b => b !== '-' && b !== '.');
          if (nonGapCol.length === 0) {
            consensus.push('-');
            continue;
          }
          const counts = {};
          nonGapCol.forEach(b => counts[b] = (counts[b] || 0) + 1);
          const maxCount = Math.max(...Object.values(counts));
          const maxBases = Object.keys(counts).filter(b => counts[b] === maxCount);
          const freq = maxCount / col.length;
          if (freq < threshold) {
            consensus.push('-');
            continue;
          }
          if (consType === 'ambiguous') {
            if (maxBases.length > 1) {
              const standardBases = maxBases.filter(b => ['A', 'C', 'G', 'T'].includes(b));
              if (standardBases.length >= 2) {
                const key = standardBases.sort().join(',');
                consensus.push(ambiguousMap[key] || '-');
              } else if (maxBases.length === 1) {
                consensus.push(maxBases[0]);
              } else {
                consensus.push('-');
              }
            } else {
              consensus.push(maxBases[0]);
            }
          } else {
            if (maxBases.length === 1 && !ambiguous.has(maxBases[0])) {
              consensus.push(maxBases[0]);
            } else {
              const normalBases = ['A', 'C', 'G', 'T'].filter(b => counts[b]);
              if (normalBases.length > 0) {
                const maxNormalCount = Math.max(...normalBases.map(b => counts[b] || 0));
                const maxNormalBases = normalBases.filter(b => (counts[b] || 0) === maxNormalCount);
                consensus.push(maxNormalBases[0]);
              } else {
                consensus.push('-');
              }
            }
          }
        }
      }
      consensusSeq = consensus.join('').replace(/-/g, '');
      // Determine order
      const consensusPosition = document.querySelector('input[name="consensusPosition"]:checked')?.value || 'bottom';
      const tooltip = document.getElementById('tooltip');
      if (useBlocks) {
        for (let start = 0; start < len; start += blockWidth) {
          const end = Math.min(start + blockWidth, len);
          const blockDiv = document.createElement('div');
          blockDiv.className = 'block-block';
          const sep = document.createElement('div');
          sep.className = 'block-sep';
          sep.textContent = `--- ${start + 1}-${end} ---`;
          blockDiv.appendChild(sep);
          if (showConsensus && consensusPosition === 'top') {
            addConsensusLine(blockDiv, consensus, start, end, nameLen);
          }
          for (let i = 0; i < seqs.length; i++) {
            const lineDiv = document.createElement('div');
            lineDiv.className = 'seq-line';
            lineDiv.dataset.seqIndex = i;
            const nameSpan = document.createElement('div');
            nameSpan.className = 'seq-name';
            nameSpan.title = seqs[i].fullHeader;
            nameSpan.textContent = seqs[i].header.substring(0, nameLen);
            lineDiv.appendChild(nameSpan);
            const dataSpan = document.createElement('div');
            dataSpan.className = 'seq-data';
            for (let pos = start; pos < end; pos++) {
              const base = seqs[i].seq[pos] || '-';
              const gaplessPos = seqs[i].gaplessPositions[pos];
              let cls = 'other';
              let baseClass = '';
              if (!standard.has(base) && !ambiguous.has(base)) {
                baseClass = 'artifact';
              } else if (ambiguous.has(base)) {
                baseClass = 'ambiguous';
              }
              const col = seqs.map(s => s.seq[pos] || '-');
              const nonGapCol = col.filter(b => b !== '-' && b !== '.');
              if (nonGapCol.length > 0) {
                const counts = {};
                nonGapCol.forEach(b => counts[b] = (counts[b] || 0) + 1);
                const maxCount = Math.max(...Object.values(counts), 0);
                const consensusBases = new Set(Object.keys(counts).filter(b => counts[b] === maxCount));
                const denominator = document.querySelector('input[name="shadeMode"]:checked').value === 'all' ? seqs.length : nonGapCol.length;
                const conservation = maxCount / denominator;
                if (base !== '-' && base !== '.' && consensusBases.has(base)) {
                  if (enableBlack && conservation >= blackThresh) cls = 'black';
                  else if (enableDark && conservation >= darkThresh) cls = 'dark';
                  else if (enableLight && conservation >= lightThresh) cls = 'light';
                } else if (base === '-' || base === '.') {
                  cls = 'gap';
                }
              } else {
                cls = 'gap';
              }
              const newClass = `${cls} ${baseClass}`.trim();
              const span = document.createElement('span');
              span.className = newClass;
              span.textContent = base;
              span.dataset.pos = pos;
              if (base !== '-' && base !== '.') {
                const currentGaplessPos = gaplessPos;
                span.onmouseover = (e) => {
                  tooltip.style.display = 'block';
                  tooltip.textContent = `${seqs[i].header}: ${currentGaplessPos}`;
                  tooltip.style.left = (e.pageX + 10) + 'px';
                  tooltip.style.top = (e.pageY - 20) + 'px';
                };
                span.onmouseout = () => {
                  tooltip.style.display = 'none';
                };
              } else {
                span.title = 'Gap';
              }
              if (selectedColumns.has(pos)) {
                span.classList.add('column-selected');
              }
              dataSpan.appendChild(span);
            }
            lineDiv.appendChild(dataSpan);
            blockDiv.appendChild(lineDiv);
            if (selectedRows.has(i)) {
              lineDiv.classList.add('selected');
            }
          }
          if (showConsensus && consensusPosition === 'bottom') {
            addConsensusLine(blockDiv, consensus, start, end, nameLen);
          }
          container.appendChild(blockDiv);
        }
      } else {
        if (showConsensus && consensusPosition === 'top') {
          addConsensusLine(container, consensus, 0, len, nameLen);
        }
        for (let i = 0; i < seqs.length; i++) {
          const lineDiv = document.createElement('div');
          lineDiv.className = 'seq-line';
          lineDiv.dataset.seqIndex = i;
          const nameSpan = document.createElement('div');
          nameSpan.className = 'seq-name';
          nameSpan.title = seqs[i].fullHeader;
          nameSpan.textContent = seqs[i].header.substring(0, nameLen);
          lineDiv.appendChild(nameSpan);
          const dataSpan = document.createElement('div');
          dataSpan.className = 'seq-data';
          for (let pos = 0; pos < len; pos++) {
            const base = seqs[i].seq[pos] || '-';
            const gaplessPos = seqs[i].gaplessPositions[pos];
            let cls = 'other';
            let baseClass = '';
            if (!standard.has(base) && !ambiguous.has(base)) {
              baseClass = 'artifact';
            } else if (ambiguous.has(base)) {
              baseClass = 'ambiguous';
            }
            const col = seqs.map(s => s.seq[pos] || '-');
            const nonGapCol = col.filter(b => b !== '-' && b !== '.');
            if (nonGapCol.length > 0) {
              const counts = {};
              nonGapCol.forEach(b => counts[b] = (counts[b] || 0) + 1);
              const maxCount = Math.max(...Object.values(counts), 0);
              const consensusBases = new Set(Object.keys(counts).filter(b => counts[b] === maxCount));
              const denominator = document.querySelector('input[name="shadeMode"]:checked').value === 'all' ? seqs.length : nonGapCol.length;
              const conservation = maxCount / denominator;
              if (base !== '-' && base !== '.' && consensusBases.has(base)) {
                if (enableBlack && conservation >= blackThresh) cls = 'black';
                else if (enableDark && conservation >= darkThresh) cls = 'dark';
                else if (enableLight && conservation >= lightThresh) cls = 'light';
              } else if (base === '-' || base === '.') {
                cls = 'gap';
              }
            } else {
              cls = 'gap';
            }
            const newClass = `${cls} ${baseClass}`.trim();
            const span = document.createElement('span');
            span.className = newClass;
            span.textContent = base;
            span.dataset.pos = pos;
            if (base !== '-' && base !== '.') {
              const currentGaplessPos = gaplessPos;
              span.onmouseover = (e) => {
                tooltip.style.display = 'block';
                tooltip.textContent = `${seqs[i].header}: ${currentGaplessPos}`;
                tooltip.style.left = (e.pageX + 10) + 'px';
                tooltip.style.top = (e.pageY - 20) + 'px';
              };
              span.onmouseout = () => {
                tooltip.style.display = 'none';
              };
            } else {
              span.title = 'Gap';
            }
            if (selectedColumns.has(pos)) {
              span.classList.add('column-selected');
            }
            dataSpan.appendChild(span);
          }
          lineDiv.appendChild(dataSpan);
          container.appendChild(lineDiv);
          if (selectedRows.has(i)) {
            lineDiv.classList.add('selected');
          }
        }
        if (showConsensus && consensusPosition === 'bottom') {
          addConsensusLine(container, consensus, 0, len, nameLen);
        }
      }
    }
    function addConsensusLine(parent, consensus, start, end, nameLen) {
      const consLine = document.createElement('div');
      consLine.className = 'seq-line consensus-line';
      const consName = document.createElement('div');
      consName.className = 'seq-name';
      consName.textContent = 'Consensus';
      consLine.appendChild(consName);
      const dataSpan = document.createElement('div');
      dataSpan.className = 'seq-data';
      for (let pos = start; pos < end; pos++) {
        const base = pos < consensus.length ? consensus[pos] : '-';
        let baseClass = '';
        if (!['A','C','G','T','U','N','-','.'].includes(base)) baseClass = 'artifact';
        else if (['R','Y','M','K','S','W','H','B','V','D'].includes(base)) baseClass = 'ambiguous';
        const span = document.createElement('span');
        span.className = baseClass;
        span.textContent = base;
        dataSpan.appendChild(span);
      }
      consLine.appendChild(dataSpan);
      parent.appendChild(consLine);
    }
    function setZoom(percent) {
      const size = (percent / 100) * 13;
      const container = document.getElementById('alignmentContainer');
      container.style.fontSize = size + 'px';
      document.getElementById('zoomVal').textContent = percent;
    }
    function debounce(func, delay) {
      let timer;
      return () => {
        clearTimeout(timer);
        timer = setTimeout(func, delay);
      };
    }
    const debounceRender = debounce(renderAlignment, 100);
    window.parseAndRender = function(isFromDrop = false) {
      const fasta = document.getElementById('fastaInput').value.trim();
      if (!fasta) {
        document.getElementById('alignmentContainer').innerHTML = '<div class="error-message">‚ùå No input provided. Paste or drop a FASTA file.</div>';
        return;
      }
      try {
        const parsed = parseFasta(fasta);
        if (!parsed) throw new Error("No valid sequences found");
        seqs = parsed;
        selectedRows.clear();
        selectedColumns.clear();
        lastSelectedIndex = null;
        if (!isFromDrop) {
          currentFilename = 'Clipboard';
        }
        document.getElementById('filenameInfo').textContent = `Source: ${currentFilename}`;
        renderAlignment();
      } catch (e) {
        console.error("Error in parseAndRender:", e);
        document.getElementById('alignmentContainer').innerHTML = `<div class="error-message">‚ùå ${e.message}</div>`;
      }
    };
    function onModeChange() {
      toggleBlockSize();
      renderAlignment();
    }
    function toggleBlockSize() {
      const container = document.getElementById('blockSizeContainer');
      if (container) {
        container.style.display = document.getElementById('modeBlocks').checked ? 'inline' : 'none';
      }
    }
    window.onShadeModeChange = function() {
      validateThresholds();
      debounceRender();
    };
    // Continuous selection
    document.getElementById('alignmentContainer').onmousedown = function(e) {
      const row = e.target.closest('.seq-line');
      if (!row || row.classList.contains('consensus-line')) return;
      const index = parseInt(row.dataset.seqIndex);
      if (e.ctrlKey || e.metaKey) {
        row.classList.toggle('selected');
        if (row.classList.contains('selected')) selectedRows.add(index);
        else selectedRows.delete(index);
        lastSelectedIndex = index;
        isDragging = true;
        dragStartRow = index;
      } else if (e.shiftKey && lastSelectedIndex !== null) {
        selectedRows.clear();
        const start = Math.min(lastSelectedIndex, index);
        const end = Math.max(lastSelectedIndex, index);
        for (let i = start; i <= end; i++) {
          selectedRows.add(i);
        }
        debounceRender();
      } else if (e.ctrlKey && e.altKey) {
        const span = e.target.closest('.seq-data span');
        if (!span) return;
        const pos = parseInt(span.dataset.pos);
        if (isNaN(pos)) return;
        const isSelected = span.classList.toggle('column-selected');
        if (isSelected) {
          selectedColumns.add(pos);
        } else {
          selectedColumns.delete(pos);
        }
        document.querySelectorAll(`.seq-data span[data-pos="${pos}"]`).forEach(s => {
          s.classList.toggle('column-selected', isSelected);
        });
        e.preventDefault();
        isDragging = true;
        dragStartCol = pos;
      } else {
        if (!e.ctrlKey) {
          selectedRows.clear();
        }
        selectedRows.add(index);
        lastSelectedIndex = index;
        isDragging = true;
        dragStartRow = index;
        debounceRender();
      }
    };
    document.getElementById('alignmentContainer').onmousemove = function(e) {
      if (!isDragging) return;
      if (dragStartRow !== null) {
        const row = e.target.closest('.seq-line');
        if (row) {
          const index = parseInt(row.dataset.seqIndex);
          if (!e.ctrlKey) {
            selectedRows.clear();
          }
          const start = Math.min(dragStartRow, index);
          const end = Math.max(dragStartRow, index);
          for (let i = start; i <= end; i++) {
            selectedRows.add(i);
          }
          debounceRender();
        }
      } else if (dragStartCol !== null) {
        const span = e.target.closest('.seq-data span');
        if (span) {
          const pos = parseInt(span.dataset.pos);
          if (isNaN(pos)) return;
          document.querySelectorAll('.column-selected').forEach(s => s.classList.remove('column-selected'));
          selectedColumns.clear();
          const start = Math.min(dragStartCol, pos);
          const end = Math.max(dragStartCol, pos);
          for (let p = start; p <= end; p++) {
            selectedColumns.add(p);
            document.querySelectorAll(`.seq-data span[data-pos="${p}"]`).forEach(s => s.classList.add('column-selected'));
          }
        }
      }
    };
    document.onmouseup = function() {
      isDragging = false;
      dragStartRow = null;
      dragStartCol = null;
    };
    function reverseComplement(seq) {
      const complement = { 'A':'T','T':'A','C':'G','G':'C','N':'N','-':'-','.':'.',
        'U':'A','R':'Y','Y':'R','M':'K','K':'M','S':'S','W':'W','H':'D','B':'V','V':'B','D':'H' };
      return seq.split('').reverse().map(b => complement[b] || 'N').join('');
    }
    window.reverseComplementSelected = function() {
      if (selectedRows.size === 0) {
        alert("Select sequences (Ctrl+click) to RevComp.");
        return;
      }
      for (const i of selectedRows) {
        if (i < seqs.length) {
          seqs[i] = {
            ...seqs[i],
            seq: reverseComplement(seqs[i].seq)
          };
          seqs[i].gaplessPositions = calculateGaplessPositions(seqs[i].seq);
        }
      }
      renderAlignment();
    };
    window.deleteSelected = function() {
      if (selectedRows.size === 0) {
        alert("No sequences selected for deletion.");
        return;
      }
      if (seqs.length === 1) {
        alert("Cannot delete the last sequence.");
        return;
      }
      if (confirm(`Delete ${selectedRows.size} sequence(s)?`)) {
        deletedHistory.push({
          seqs: JSON.parse(JSON.stringify(seqs)),
          selectedRows: new Set(selectedRows),
          selectedColumns: new Set(selectedColumns)
        });
        const indicesToDelete = Array.from(selectedRows).sort((a,b)=>b-a);
        for (const index of indicesToDelete) {
          if (index < seqs.length) {
            seqs.splice(index, 1);
          }
        }
        selectedRows.clear();
        lastSelectedIndex = null;
        renderAlignment();
      }
    };
    window.undoDelete = function() {
      if (deletedHistory.length === 0) {
        alert("Nothing to undo.");
        return;
      }
      const last = deletedHistory.pop();
      seqs = last.seqs;
      selectedRows = last.selectedRows;
      if (last.selectedColumns) {
        selectedColumns = last.selectedColumns;
      }
      renderAlignment();
    };
    function copySelected() {
      if (selectedRows.size === 0) {
        alert("No sequences selected to copy.");
        return;
      }
      const fasta = Array.from(selectedRows).sort((a,b) => a - b).map(i => {
        const s = seqs[i];
        return `>${s.fullHeader || s.header}\n${s.seq}`;
      }).join('\n');
      navigator.clipboard.writeText(fasta).then(() => {
        alert("Selected sequences copied as FASTA!");
      }).catch(err => {
        console.error('Copy failed:', err);
        alert("Failed to copy. Check console.");
      });
    }
    function copyConsensus() {
      if (!consensusSeq) {
        alert("No consensus available to copy.");
        return;
      }
      const fasta = `>Consensus\n${consensusSeq}`;
      navigator.clipboard.writeText(fasta).then(() => {
        alert("Consensus copied as FASTA!");
      }).catch(err => {
        console.error('Copy failed:', err);
        alert("Failed to copy. Check console.");
      });
    }
    function copySelectedConsensus() {
      if (selectedRows.size < 2) {
        alert("Select at least 2 sequences to compute consensus.");
        return;
      }
      const selectedSeqs = Array.from(selectedRows).map(i => seqs[i].seq);
      const len = Math.max(...selectedSeqs.map(s => s.length));
      const threshold = 0.5;
      let cons = '';
      for (let pos = 0; pos < len; pos++) {
        const col = selectedSeqs.map(s => s[pos] || '-').filter(b => b !== '-' && b !== '.');
        if (col.length === 0) continue;
        const counts = {};
        col.forEach(b => counts[b] = (counts[b] || 0) + 1);
        const maxBase = Object.keys(counts).reduce((a, b) => counts[a] > counts[b] ? a : b, '');
        const freq = counts[maxBase] / col.length;
        if (freq >= threshold) {
          cons += maxBase;
        }
      }
      const fasta = `>Selected_Consensus\n${cons}`;
      navigator.clipboard.writeText(fasta).then(() => {
        alert("Selected sequences consensus copied as FASTA!");
      }).catch(err => {
        console.error('Copy failed:', err);
        alert("Failed to copy. Check console.");
      });
    }
    window.copySelectedColumns = function() {
      if (selectedColumns.size === 0) {
        alert("No columns selected to copy.");
        return;
      }
      const cols = Array.from(selectedColumns).sort((a,b) => a - b);
      const fasta = seqs.map(s => {
        let seq = '';
        for (const pos of cols) {
          seq += s.seq[pos] || '-';
        }
        return `>${s.fullHeader || s.header}\n${seq}`;
      }).join('\n');
      navigator.clipboard.writeText(fasta).then(() => {
        alert("Selected columns copied as FASTA!");
      }).catch(err => {
        console.error('Copy failed:', err);
        alert("Failed to copy.");
      });
    };
    window.deleteSelectedColumns = function() {
      if (selectedColumns.size === 0) {
        alert("No columns selected for deletion.");
        return;
      }
      if (confirm(`Delete ${selectedColumns.size} column(s)?`)) {
        deletedHistory.push({
          seqs: JSON.parse(JSON.stringify(seqs)),
          selectedRows: new Set(selectedRows),
          selectedColumns: new Set(selectedColumns)
        });
        const colsToDelete = Array.from(selectedColumns).sort((a,b) => b - a);
        seqs = seqs.map(s => {
          let seq = s.seq.split('');
          for (const pos of colsToDelete) {
            if (pos < seq.length) seq.splice(pos, 1);
          }
          s.gaplessPositions = calculateGaplessPositions(seq.join(''));
          return { ...s, seq: seq.join('') };
        });
        selectedColumns.clear();
        renderAlignment();
      }
    };
    let allSelected = false;
    window.selectAllSequences = function() {
      if (allSelected) {
        selectedRows.clear();
        allSelected = false;
        alert("All sequences deselected.");
      } else {
        selectedRows.clear();
        for (let i = 0; i < seqs.length; i++) {
          selectedRows.add(i);
        }
        allSelected = true;
        alert("All sequences selected.");
      }
      renderAlignment();
    };
    function savePreset() {
      const preset = {
        black: document.getElementById('blackSlider').value,
        dark: document.getElementById('darkSlider').value,
        light: document.getElementById('lightSlider').value,
        zoom: document.getElementById('zoomSlider').value,
        mode: document.getElementById('modeBlocks').checked ? 'blocks' : 'single',
        blockSize: document.getElementById('blockSizeSlider').value,
        nameLen: document.getElementById('nameLengthSlider').value,
        consensusThreshold: document.getElementById('consensusThreshold').value,
        consensusType: document.querySelector('input[name="consensusType"]:checked').value,
        showConsensus: document.getElementById('showConsensus').checked,
        consensusPosition: document.querySelector('input[name="consensusPosition"]:checked').value,
        shadeMode: document.querySelector('input[name="shadeMode"]:checked').value,
        enableBlack: document.getElementById('enableBlack').checked,
        enableDark: document.getElementById('enableDark').checked,
        enableLight: document.getElementById('enableLight').checked
      };
      localStorage.setItem('qwen_msa_viewer_preset_v44', JSON.stringify(preset));
      alert("Preset saved!");
    }
    function loadPreset() {
      const saved = localStorage.getItem('qwen_msa_viewer_preset_v44');
      if (!saved) {
        alert("No saved preset found.");
        return;
      }
      const p = JSON.parse(saved);
      ['black','dark','light','zoom','blockSize','nameLen','consensusThreshold'].forEach(k => {
        document.getElementById(k + 'Slider').value = p[k];
        document.getElementById(k + 'Input').value = p[k];
        updateLabel(k + 'Val', p[k]);
      });
      setZoom(p.zoom);
      document.getElementById('modeBlocks').checked = p.mode === 'blocks';
      document.getElementById('modeSingle').checked = p.mode !== 'blocks';
      toggleBlockSize();
      document.querySelector(`input[name="consensusType"][value="${p.consensusType}"]`).checked = true;
      document.getElementById('showConsensus').checked = p.showConsensus;
      document.querySelector(`input[name="consensusPosition"][value="${p.consensusPosition}"]`).checked = true;
      document.querySelector(`input[name="shadeMode"][value="${p.shadeMode}"]`).checked = true;
      document.getElementById('enableBlack').checked = p.enableBlack;
      document.getElementById('enableDark').checked = p.enableDark;
      document.getElementById('enableLight').checked = p.enableLight;
      renderAlignment();
    }
    function minimizeMenu() {
      const controls = document.getElementById('controls');
      const filenameInfo = document.getElementById('filenameInfo');
      minimizeBar.parentNode.insertBefore(filenameInfo, minimizeBar.nextSibling);
      filenameInfo.style.position = 'sticky';
      filenameInfo.style.top = '20px';
      filenameInfo.style.zIndex = '98';
      controls.style.display = 'none';
      minimizeBar.style.display = 'block';
    }
    function expandMenu() {
      minimizeBar.style.display = 'none';
      const controls = document.getElementById('controls');
      const filenameInfo = document.getElementById('filenameInfo');
      controls.appendChild(filenameInfo);
      filenameInfo.style.position = '';
      filenameInfo.style.top = '';
      filenameInfo.style.zIndex = '';
      controls.style.display = 'grid';
    }
    function validateThresholds() {
      const b = parseInt(document.getElementById('blackSlider').value);
      const d = parseInt(document.getElementById('darkSlider').value);
      const l = parseInt(document.getElementById('lightSlider').value);
      if (b < d) document.getElementById('darkSlider').value = document.getElementById('darkInput').value = b;
      if (d < l) document.getElementById('lightSlider').value = document.getElementById('lightInput').value = d;
      ['blackVal','darkVal','lightVal'].forEach(id => updateLabel(id, document.getElementById(id.replace('Val','Slider')).value));
    }
    function searchMotif() {
      const motif = document.getElementById('searchInput').value.trim().toUpperCase();
      if (!motif) return;
      const color = document.getElementById('searchColor').value;
      const className = 'search-hit-' + Math.random().toString(36).substring(2, 12) + btoa(motif).replace(/=/g, '').substring(0, 5);
      searchHistory = searchHistory.filter(item => {
        if (item.motif === motif) {
          document.querySelectorAll(`.${item.className}`).forEach(span => {
            span.classList.remove(item.className);
          });
          document.querySelector(`style[data-motif="${item.motif}"]`)?.remove();
          return false;
        }
        return true;
      });
      const style = document.createElement('style');
      style.textContent = `.${className} { background-color: ${color} !important; color: black !important; font-weight: bold; }`;
      style.setAttribute('data-motif', motif);
      document.head.appendChild(style);
      searchHistory.push({ motif, color, className });
      document.querySelectorAll('.seq-line:not(.consensus-line)').forEach(row => {
        const index = parseInt(row.dataset.seqIndex);
        if (index >= seqs.length || index < 0) return;
        const seq = seqs[index].seq;
        const degapped = seq.replace(/[-.]/g, '');
        const dataSpan = row.querySelector('.seq-data');
        const spans = Array.from(dataSpan.children);
        const nonGapSpans = spans.filter(s => {
          const b = s.textContent;
          return b !== '-' && b !== '.';
        });
        for (let seqPos = 0; seqPos <= degapped.length - motif.length; seqPos++) {
          const sub = degapped.substring(seqPos, seqPos + motif.length);
          if (sub === motif) {
            for (let i = 0; i < motif.length; i++) {
              const child = nonGapSpans[seqPos + i];
              if (child) child.classList.add(className);
            }
          }
        }
      });
      document.getElementById('searchInput').value = '';
    }
    window.clearLastSearch = function() {
      if (searchHistory.length === 0) return;
      const last = searchHistory.pop();
      document.querySelectorAll(`.${last.className}`).forEach(span => span.classList.remove(last.className));
      document.querySelector(`style[data-motif="${last.motif}"]`)?.remove();
    };
    function clearAllSearches() {
      searchHistory.forEach(item => {
        document.querySelectorAll(`.${item.className}`).forEach(span => {
          span.classList.remove(item.className);
        });
        document.querySelector(`style[data-motif="${item.motif}"]`)?.remove();
      });
      searchHistory = [];
    }
    const infoModal = document.getElementById('infoModal');
    window.openInfoModal = function() {
      infoModal.style.display = 'block';
    };
    window.closeInfoModal = function() {
      infoModal.style.display = 'none';
    };
    window.onclick = function(event) {
      if (event.target == infoModal) {
        closeInfoModal();
      }
    };
    // Init
    document.getElementById('modeBlocks').checked = true;
    document.getElementById('modeSingle').checked = false;
    document.querySelector('input[name="consensusPosition"][value="bottom"]').checked = true;
    toggleBlockSize();
  </script>
</body>
</html>
