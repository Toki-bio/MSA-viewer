<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Qwen MSA Viewer - Final Edition</title>
  <style>
    :root {
      --nameLen: 20;
      --slider-value: 0%;
      --slider-fill: #888;
      --selected-bg: #90ee90;
      --column-selected-bg: #a5d6a7;
      --nuc-selected-bg: #ffff00;
      --tooltip-bg: white;
      --tooltip-border: #ccc;
      --modal-bg: #fefefe;
      --modal-border: #888;
      --dropzone-bg: #f0f8ff;
      --dropzone-hover-bg: #e0f0ff;
      --dropzone-border: #1a2129;
      --dropzone-hover-border: #004c99;
      --control-bg: white;
      --button-bg: white;
      --button-hover-bg: #e6f3ff;
      --button-border: #ccc;
      --block-sep-bg: #f0f0f0;
      --error-bg: #ffe6e6;
      --error-border: #ff8080;
      --search-hit-bg: yellow;
    }
    body {
      font-family: 'Courier New', monospace;
      font-size: 13px;
      margin: 0;
      padding: 0;
      background: white;
      color: black;
      height: 100vh;
      display: flex;
      flex-direction: column;
    }
    #dropZone {
      border: 2px dashed var(--dropzone-border);
      border-radius: 4px;
      padding: 8px;
      text-align: center;
      color: #555;
      font-size: 13px;
      background: var(--dropzone-bg);
      display: flex;
      align-items: center;
      justify-content: center;
      min-height: 40px;
    }
    #dropZone:hover {
      border-color: var(--dropzone-hover-border);
      background: var(--dropzone-hover-bg);
    }
    #controls {
      position: sticky;
      top: 0;
      background: var(--control-bg);
      padding: 6px 8px;
      border-bottom: 1px solid #ddd;
      z-index: 100;
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
      gap: 6px;
      font-size: 13px;
    }
    .menu-section {
      margin-bottom: 4px;
    }
    .section-header {
      font-size: 14px;
      margin: 4px 0;
      color: #2c3e50;
      font-weight: bold;
    }
    .button-group {
      display: flex;
      flex-wrap: wrap;
      gap: 4px;
      align-items: center;
      font-size: 12px;
      border: 1px solid #eee;
      border-radius: 4px;
      padding: 2px;
      background: #fafafa;
    }
    .button-spacer {
      width: 1px;
      height: 16px;
      background: #ccc;
      margin: 0 4px;
    }
    button {
      padding: 2px 6px;
      margin: 1px;
      font-size: 12px;
      border: 1px solid var(--button-border);
      border-radius: 3px;
      background: var(--button-bg);
      cursor: pointer;
    }
    button:hover {
      background: var(--button-hover-bg);
    }
    .control-group {
      display: block;
      margin: 2px 0;
    }
    .slider-container {
      margin: 2px 0;
      display: flex;
      align-items: center;
      gap: 6px;
      height: 22px;
      line-height: 22px;
    }
    .display-slider-row {
      min-width: 340px;
      display: flex;
      align-items: center;
      gap: 8px;
      flex-wrap: nowrap;
    }
    .slider-label {
      width: 70px;
      display: inline-block;
      text-align: right;
      font-weight: normal;
      white-space: nowrap;
    }
    input[type="range"].shading-slider {
      -webkit-appearance: none;
      width: 130px;
      height: 22px;
      background: transparent;
      outline: none;
    }
    input[type="range"].shading-slider::-webkit-slider-runnable-track {
      height: 8px;
      border-radius: 4px;
      cursor: pointer;
      background: linear-gradient(to right, var(--slider-fill) 0%, var(--slider-fill) var(--slider-value), #e0e0e0 var(--slider-value), #e0e0e0 100%);
    }
    input[type="range"].shading-slider::-moz-range-track {
      height: 8px;
      border-radius: 4px;
      cursor: pointer;
      background: linear-gradient(to right, var(--slider-fill) 0%, var(--slider-fill) var(--slider-value), #e0e0e0 var(--slider-value), #e0e0e0 100%);
    }
    #blackSlider { --slider-fill: #000; }
    #darkSlider { --slider-fill: #555; }
    #lightSlider { --slider-fill: #ccc; }
    #groupConsensusThreshold { --slider-fill: #888; }
    input[type="range"].shading-slider::-webkit-slider-thumb {
      -webkit-appearance: none;
      height: 14px;
      width: 8px;
      border: 2px solid black;
      border-radius: 2px;
      margin-top: -3px;
      cursor: pointer;
      background: white;
    }
    input[type="range"].shading-slider::-moz-range-thumb {
      height: 14px;
      width: 8px;
      border: 2px solid black;
      border-radius: 2px;
      cursor: pointer;
      background: white;
    }
    input[type="range"].normal-slider {
      -webkit-appearance: none;
      width: 130px;
      height: 14px;
      background: transparent;
      outline: none;
    }
    input[type="range"].normal-slider::-webkit-slider-runnable-track {
      height: 7px;
      border-radius: 7px;
      background: linear-gradient(to right, #888 0%, #888 var(--slider-value), #e0e0e0 var(--slider-value), #e0e0e0 100%);
    }
    input[type="range"].normal-slider::-moz-range-track {
      height: 7px;
      border-radius: 7px;
      background: linear-gradient(to right, #888 0%, #888 var(--slider-value), #e0e0e0 var(--slider-value), #e0e0e0 100%);
    }
    input[type="range"].normal-slider::-webkit-slider-thumb {
      -webkit-appearance: none;
      width: 8px;
      height: 14px;
      border: 2px solid black;
      border-radius: 2px;
      background: white;
      cursor: pointer;
      margin-top: -3px;
    }
    input[type="range"].normal-slider::-moz-range-thumb {
      width: 8px;
      height: 14px;
      border: 2px solid black;
      border-radius: 2px;
      background: white;
      cursor: pointer;
    }
    input[type="number"] {
      width: 32px;
      height: 18px;
      padding: 0;
      text-align: center;
      font-size: 12px;
    }
    .block-block {
      margin-bottom: 8px;
    }
    .block-sep {
      font-weight: bold;
      color: #666;
      text-align: center;
      margin: 4px 0;
      padding: 2px 0;
      background: var(--block-sep-bg);
      border-radius: 3px;
    }
    #alignmentContainer {
      flex: 1;
      overflow-x: auto;
      overflow-y: auto;
      background: white;
      font-family: 'Courier New', monospace;
      line-height: 1.0;
      white-space: pre;
      border: 1px solid #ddd;
      font-size: 13px;
      transition: font-size 0.1s;
      user-select: none;
      -moz-user-select: none;
      -webkit-user-select: none;
      -ms-user-select: none;
      position: relative;
    }
    .seq-line {
      display: flex;
      font-family: 'Courier New', monospace;
      line-height: 1.0;
      margin: 0;
      padding: 0;
      white-space: nowrap;
      user-select: none;
      -moz-user-select: none;
      -webkit-user-select: none;
      -ms-user-select: none;
    }
    .seq-name {
      flex: 0 0 auto;
      min-width: calc(var(--nameLen) * 0.6em);
      width: calc(var(--nameLen) * 0.6em);
      max-width: calc(var(--nameLen) * 0.6em);
      text-align: left;
      padding: 0 2px 0 0;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
      font-weight: bold;
      color: #333;
      background: white !important;
      cursor: default;
      position: sticky;
      left: 0;
      z-index: 11;
      user-select: none;
      -moz-user-select: none;
      -webkit-user-select: none;
      -ms-user-select: none;
    }
    .seq-name.static {
      position: static;
    }
    .seq-name:hover {
      background-color: #f0f0f0;
      color: #000;
    }
    .seq-data {
      flex: 1;
      display: inline-block;
      white-space: nowrap;
      margin: 0;
      padding: 0;
      line-height: 1.0;
      user-select: none;
      -moz-user-select: none;
      -webkit-user-select: none;
      -ms-user-select: none;
      cursor: default;
    }
    .seq-data:active {
      cursor: grabbing;
    }
    .seq-data span {
      user-select: none;
      -moz-user-select: none;
      -webkit-user-select: none;
      -ms-user-select: none;
    }
    .seq-data span:not(.nuc-selected):hover {
      cursor: default;
    }
    .black { background-color: #000 !important; color: white; }
    .dark { background-color: #555; color: white; }
    .light { background-color: #ccc; color: black; }
    .gap { background-color: white !important; color: #888 !important; }
    .other { background-color: white; color: black; }
    .ambiguous { color: #0000AA; font-weight: bold; }
    .artifact {
      color: red !important;
      background-color: #ffe6e6 !important;
      font-weight: bold !important;
    }
    .selected .seq-name {
      background-color: var(--selected-bg) !important;
      color: #000 !important;
      font-weight: bold;
    }
    .selected .seq-data span {
      background-color: #e0ffe0 !important;
      color: black !important;
    }
    .column-selected {
      background-color: var(--column-selected-bg) !important;
      color: black !important;
    }
    .nuc-selected {
      background-color: var(--nuc-selected-bg) !important;
      color: black !important;
    }
    .nuc-selected:hover {
      cursor: pointer;
    }
    .consensus-line {
      border-top: 1px solid #ccc;
      margin-top: 4px;
      font-style: normal;
      color: #555;
      font-weight: bold;
    }
    .consensus-line .seq-name {
      color: #555;
      font-weight: bold;
      background: white !important;
      z-index: 11;
    }
    .consensus-line .seq-data span {
      opacity: 0.9;
      background-color: transparent !important;
      color: #555;
    }
    .error-message {
      color: red;
      font-weight: bold;
      padding: 10px;
      background: var(--error-bg);
      border: 1px solid var(--error-border);
      margin: 5px;
      border-radius: 4px;
    }
    .search-hit {
      background-color: var(--search-hit-bg) !important;
      color: black !important;
      font-weight: bold;
    }
    .tooltip {
      position: absolute;
      background: var(--tooltip-bg);
      color: black;
      font-size: 12px;
      padding: 2px 6px;
      border-radius: 3px;
      white-space: nowrap;
      z-index: 200;
      display: none;
      border: 1px solid var(--tooltip-border);
    }
    .modal {
      display: none;
      position: fixed;
      z-index: 1000;
      left: 0;
      top: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(0,0,0,0.5);
    }
    .modal-content {
      background-color: var(--modal-bg);
      margin: 5% auto;
      padding: 20px;
      border: 1px solid var(--modal-border);
      width: 80%;
      max-width: 800px;
      max-height: 80vh;
      overflow-y: auto;
      border-radius: 8px;
      font-family: Arial, sans-serif;
      line-height: 1.6;
    }
    .close {
      color: #aaa;
      float: right;
      font-size: 28px;
      font-weight: bold;
      cursor: pointer;
    }
    .close:hover,
    .close:focus {
      color: black;
      text-decoration: none;
    }
    .modal h2, .modal h3 {
      color: #2c3e50;
    }
    .modal ul {
      margin: 10px 0;
      padding-left: 20px;
    }
    .zoom-buttons {
      display: flex;
      gap: 4px;
      align-items: center;
      width: 60px;
      justify-content: space-between;
    }
    .zoom-button {
      width: 18px;
      height: 18px;
      min-width: 18px;
      min-height: 18px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 12px;
      padding: 0;
      border-radius: 50%;
      line-height: 18px;
      text-align: center;
      box-sizing: border-box;
    }
    .zoom-value {
      width: 30px;
      min-width: 30px;
      text-align: center;
      display: inline-block;
    }
    .mode-container {
      display: flex;
      align-items: center;
      gap: 6px;
    }
    .shade-mode-label {
      margin-right: 8px;
    }
    #statusMessage {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: rgba(0,0,0,0.8);
      color: white;
      padding: 10px 20px;
      border-radius: 4px;
      font-size: 14px;
      z-index: 1000;
      display: none;
    }
    #minimizeBar {
      display: none;
      position: sticky;
      top: 0;
      background: white;
      padding: 4px;
      text-align: center;
      cursor: pointer;
      border-bottom: 1px solid #ddd;
      z-index: 99;
      font-size: 12px;
      color: #555;
    }
    .context-menu {
      position: absolute;
      background: white;
      border: 1px solid #ccc;
      padding: 5px;
      z-index: 1000;
    }
    .context-menu div {
      cursor: pointer;
      padding: 2px 5px;
    }
    .context-menu div:hover {
      background: #f0f0f0;
    }
  </style>
</head>
<body>
  <div id="controls">
    <h2 style="grid-column: 1/-1; text-align: center; margin: 2px 0; font-size: 16px;">Qwen MSA Viewer</h2>
    <div class="menu-section" style="grid-column: 1/-1; display: flex; gap: 6px; align-items: start;">
      <div id="dropZone" style="flex: 0 0 180px; padding: 6px;">Drop FASTA/MSF</div>
      <textarea id="fastaInput" placeholder=">seq1&#13;&#10;ATGCGGCTA..." style="flex: 1; height: 60px; font-size: 12px; padding: 4px;"></textarea>
      <button id="loadButton" style="height: 60px; font-size: 13px;" title="Load the pasted or dropped FASTA/MSF data (shortcut: Ctrl+L)">Load</button>
    </div>
    <div class="menu-section">
      <div class="section-header">Shade</div>
      <div class="control-group">
        <div class="slider-container">
          <span class="slider-label">Black</span>
          <label class="shade-mode-label">
            <input type="checkbox" id="enableBlack" checked title="Enable black shading for highly conserved positions">
          </label>
          <input type="range" id="blackSlider" class="shading-slider" min="50" max="100" value="90" title="Black shading threshold (50-100%)">
          <input type="number" id="blackInput" min="50" max="100" value="90" title="Black shading threshold (50-100%)">
        </div>
        <div class="slider-container">
          <span class="slider-label">Dark</span>
          <label class="shade-mode-label">
            <input type="checkbox" id="enableDark" checked title="Enable dark gray shading for moderately conserved positions">
          </label>
          <input type="range" id="darkSlider" class="shading-slider" min="30" max="90" value="70" title="Dark shading threshold (30-90%)">
          <input type="number" id="darkInput" min="30" max="90" value="70" title="Dark shading threshold (30-90%)">
        </div>
        <div class="slider-container">
          <span class="slider-label">Light</span>
          <label class="shade-mode-label">
            <input type="checkbox" id="enableLight" checked title="Enable light gray shading for less conserved positions">
          </label>
          <input type="range" id="lightSlider" class="shading-slider" min="10" max="80" value="50" title="Light shading threshold (10-80%)">
          <input type="number" id="lightInput" min="10" max="80" value="50" title="Light shading threshold (10-80%)">
        </div>
        <div class="slider-container">
          <span class="slider-label">Shade By</span>
          <label class="shade-mode-label">
            <input type="radio" name="shadeMode" value="nongap" title="Shade based on non-gap positions only">
            Non-Gap
          </label>
          <label class="shade-mode-label">
            <input type="radio" name="shadeMode" value="all" checked title="Shade based on all positions including gaps">
            All
          </label>
        </div>
      </div>
    </div>
    <div class="menu-section">
      <div class="section-header">Display</div>
      <div class="control-group">
        <div class="slider-container display-slider-row">
          <span class="slider-label">Name Len</span>
          <input type="range" id="nameLengthSlider" class="normal-slider" min="5" max="100" value="20" title="Adjust sequence name display length (5-100 characters)">
          <input type="number" id="nameLengthInput" min="5" max="100" value="20" title="Adjust sequence name display length (5-100 characters)">
        </div>
        <div class="slider-container display-slider-row">
          <span class="slider-label">Zoom</span>
          <input type="range" id="zoomSlider" class="normal-slider" min="50" max="200" value="100" title="Zoom level for alignment display (50-200%)">
          <span class="zoom-buttons">
            <button id="zoomOutButton" class="zoom-button" title="Zoom out (shortcut: Ctrl+-)">-</button>
            <span id="zoomVal" class="zoom-value">100%</span>
            <button id="zoomInButton" class="zoom-button" title="Zoom in (shortcut: Ctrl++)">+</button>
          </span>
        </div>
        <div class="slider-container display-slider-row" id="blockSizeContainer">
          <span class="slider-label">Block Size</span>
          <input type="range" id="blockSizeSlider" class="normal-slider" min="40" max="200" value="80" title="Block size in Block mode (40-200 characters)">
          <input type="number" id="blockSizeInput" min="40" max="200" value="80" title="Block size in Block mode (40-200 characters)">
        </div>
        <div class="slider-container mode-container">
          <span class="slider-label">Mode</span>
          <input type="radio" id="modeSingle" name="mode" value="single" title="Display full alignment in a single line">
          <label for="modeSingle">Full</label>
          <input type="radio" id="modeBlocks" name="mode" value="blocks" checked title="Display alignment in blocks for better readability">
          <label for="modeBlocks">Block</label>
        </div>
        <div class="slider-container">
          <input type="checkbox" id="stickyNames" checked title="Keep sequence names sticky when scrolling horizontally">
          <label for="stickyNames" style="font-size: 12px;">Sticky Names</label>
        </div>
      </div>
    </div>
    <div class="menu-section">
      <div class="section-header">Consensus</div>
      <div class="control-group">
        <div class="slider-container">
          <span class="slider-label">Threshold</span>
          <input type="range" id="consensusThreshold" class="normal-slider" min="50" max="100" value="70" title="Consensus threshold percentage (50-100%)">
          <input type="number" id="consensusThresholdInput" min="50" max="100" value="70" title="Consensus threshold percentage (50-100%)">
        </div>
        <div class="slider-container">
          <span class="slider-label">Group Thr</span>
          <input type="range" id="groupConsensusThreshold" class="normal-slider" min="50" max="100" value="70" title="Group consensus threshold percentage (50-100%)">
          <input type="number" id="groupConsensusThresholdInput" min="50" max="100" value="70" title="Group consensus threshold percentage (50-100%)">
        </div>
        <div class="slider-container">
          <span class="slider-label">Type</span>
          <label class="shade-mode-label">
            <input type="radio" name="consensusType" value="normal" checked title="Normal consensus (single base)">
            Normal
          </label>
          <label class="shade-mode-label">
            <input type="radio" name="consensusType" value="ambiguous" title="Ambiguous consensus (IUPAC codes)">
            Ambiguous
          </label>
        </div>
        <div class="slider-container">
          <input type="checkbox" id="showConsensus" checked title="Show consensus line">
          <label for="showConsensus" style="font-size: 12px;">Show Consensus</label>
        </div>
        <div class="slider-container">
          <span class="slider-label">Position</span>
          <label class="shade-mode-label">
            <input type="radio" name="consensusPosition" value="top" title="Show consensus at top">
            Top
          </label>
          <label class="shade-mode-label">
            <input type="radio" name="consensusPosition" value="bottom" checked title="Show consensus at bottom">
            Bottom
          </label>
        </div>
        <div class="slider-container">
          <button id="copyConsensusButton" title="Copy full consensus as FASTA (shortcut: Ctrl+Shift+K)">Copy Consensus</button>
        </div>
        <div class="slider-container">
          <button id="copySelectedConsensusButton" title="Copy consensus of selected sequences (shortcut: Ctrl+Shift+J)">Copy Sel Consensus</button>
        </div>
      </div>
    </div>
    <div class="menu-section">
      <div class="section-header">Search</div>
      <div class="control-group">
        <div class="slider-container">
          <input type="text" id="searchInput" placeholder="Enter motif..." style="width: 130px; height: 22px; padding: 2px; font-size: 12px;" title="Enter motif to search (case-insensitive, searches degapped sequences)">
          <input type="color" id="searchColor" value="#FFFF00" style="width: 30px; height: 22px; padding: 0;" title="Choose highlight color for search hits">
          <button id="searchButton" title="Find motif in sequences (shortcut: Ctrl+F)">Find</button>
          <button id="clearLastSearchButton" title="Clear last search highlight (shortcut: Ctrl+Shift+F)">Clear Last</button>
          <button id="clearAllSearchesButton" title="Clear all search highlights (shortcut: Ctrl+Alt+F)">Clear All</button>
        </div>
      </div>
    </div>
    <div class="menu-section" style="grid-column: 1/-1;">
      <div class="section-header">Actions</div>
      <div class="button-group">
        <button id="reverseComplementButton" title="Reverse complement selected sequences (shortcut: Ctrl+R)">RevComp</button>
        <div class="button-spacer"></div>
        <button id="copySelectedButton" title="Copy selected sequences or nucleotides (shortcut: Ctrl+Shift+C)">Copy Sel</button>
        <button id="deleteSelectedButton" title="Delete selected sequences (shortcut: Ctrl+Del)">Delete Sel</button>
        <button id="undoButton" title="Undo last action (shortcut: Ctrl+Z)">Undo</button>
        <div class="button-spacer"></div>
        <button id="moveUpButton" title="Move selected up (shortcut: Ctrl+Up)">Up</button>
        <button id="moveDownButton" title="Move selected down (shortcut: Ctrl+Down)">Down</button>
        <button id="moveToTopButton" title="Move selected to top (shortcut: Ctrl+Home)">To Top</button>
        <button id="moveToBottomButton" title="Move selected to bottom (shortcut: Ctrl+End)">To Bottom</button>
        <div class="button-spacer"></div>
        <button id="insertGroupConsensusButton" title="Insert consensus below selected (shortcut: Ctrl+B)">Consensus Below</button>
        <div class="button-spacer"></div>
        <button id="duplicateButton" title="Duplicate selected (shortcut: Ctrl+U)">Duplicate</button>
        <button id="openInNewTabButton" title="Open selected in new tab (shortcut: Ctrl+T)">New Tab</button>
        <div class="button-spacer"></div>
        <button id="selectAllButton" title="Select/deselect all sequences (shortcut: Ctrl+A)">Select All</button>
        <div class="button-spacer"></div>
        <button id="copyColumnsButton" title="Copy selected columns as FASTA (shortcut: Ctrl+Shift+V)">Copy Cols</button>
        <button id="deleteColumnsButton" title="Delete selected columns (shortcut: Ctrl+Shift+D)">Delete Cols</button>
        <div class="button-spacer"></div>
        <button id="realignBlockButton" title="Realign selected block (shortcut: Ctrl+Shift+R)">Realign Block</button>
        <div class="button-spacer"></div>
        <button id="savePresetButton" title="Save current settings (shortcut: Ctrl+S)">Save Preset</button>
        <button id="loadPresetButton" title="Load saved settings (shortcut: Ctrl+O)">Load Preset</button>
        <div class="button-spacer"></div>
        <button id="infoButton" title="Show program info and shortcuts (shortcut: Ctrl+I)">Program Info</button>
        <button id="minimizeBtn" title="Hide menu (shortcut: Ctrl+H)">Hide menu</button>
        <div class="button-spacer"></div>
        <button id="removeGapColumnsButton" title="Remove columns with only gaps">Remove Gap Columns</button>
        <button id="insertGapColumnAllButton" title="Insert gap column at selected position in all sequences">Insert Gap Col (All)</button>
        <button id="insertGapColumnExceptButton" title="Insert gap column at selected position in all except selected sequences">Insert Gap Col (Except Sel)</button>
      </div>
    </div>
    <div style="grid-column: 1/-1; text-align: right; font-size: 12px; color: #555;">
      <span style="white-space: nowrap;">Click name: copy name</span> |
      <span style="white-space: nowrap;">Ctrl+click name: select/deselect seq (drag for range)</span> |
      <span style="white-space: nowrap;">Shift+click name: range from last</span> |
      <span style="white-space: nowrap;">Ctrl+Alt+click nuc: select column</span> |
      <span style="white-space: nowrap;">Ctrl+click on nuc: start/extend range</span> |
      <span style="white-space: nowrap;">Right-click drag seq: slide</span> |
      <span style="white-space: nowrap;">Right-click name: menu</span>
    </div>
    <div id="filenameInfo" style="grid-column: 1/-1; padding: 2px 8px; font-size: 12px; color: #555; background: #f0f0f0; text-align: center;"></div>
  </div>
  <div id="minimizeBar" style="display: none;">Restore Menu</div>
  <div id="tooltip" class="tooltip"></div>
  <div id="infoModal" class="modal">
    <div class="modal-content">
      <span class="close" onclick="closeInfoModal()">&times;</span>
      <h2>Qwen MSA Viewer</h2>
      <p>A fast, interactive, and portable Multiple Sequence Alignment viewer.</p>
      <h3>Features</h3>
      <ul>
        <li><strong>Load FASTA/MSF:</strong> Drag & drop a file or paste text (auto-detects .msf).</li>
        <li><strong>GeneDoc Coloring:</strong> Visualize conserved regions with adjustable thresholds (Black, Dark, Light).</li>
        <li><strong>Consensus Sequence:</strong> Generate and copy consensus with normal or ambiguous base codes.</li>
        <li><strong>Sequence Selection:</strong> Ctrl+Click to select multiple names, Shift+Click for range. Simple click copies name. Perform actions like Reverse Complement, Copy, or Delete.</li>
        <li><strong>Column Selection:</strong> Use Ctrl+Alt+Click to select entire columns. Copy or delete selected columns.</li>
        <li><strong>Nucleotide Selection:</strong> With Ctrl, click to start/extend range. Use “Copy Sel” to copy.</li>
        <li><strong>Search:</strong> Find motifs with custom highlight colors. Clear individual or all searches.</li>
        <li><strong>Undo:</strong> Recover deleted sequences or columns.</li>
        <li><strong>Preset Management:</strong> Save and load your display settings.</li>
        <li><strong>Sticky Names:</strong> Option to keep sequence names visible when scrolling horizontally (works in both Full and Block modes).</li>
        <li><strong>Remove Gap Columns:</strong> Remove columns with only gaps.</li>
        <li><strong>Insert Gap Column:</strong> Insert a gap column in all or all except selected sequences.</li>
        <li><strong>Insert/Remove Single Gap:</strong> Right-click on a position to insert or remove a single gap.</li>
        <li><strong>Slide Sequence:</strong> Right-click and drag the sequence data to shift left/right.</li>
      </ul>
      <h3>Quick Tips</h3>
      <ul>
        <li>Hover over a nucleotide to see the sequence name and its <strong>gapless position</strong> (e.g., the 1st, 2nd, 3rd nucleotide in the gene).</li>
        <li>Use the "Block" mode for long alignments to improve readability.</li>
        <li>The "Hide menu" button maximizes the viewing area. Click "Restore Menu" to bring it back.</li>
        <li>Enable "Sticky Names" to keep sequence names in view while scrolling sequences.</li>
      </ul>
      <h3>Controls</h3>
      <p><strong>Shade:</strong> Adjust conservation thresholds and enable/disable shading levels.</p>
      <p><strong>Display:</strong> Change sequence name length, zoom level, block size, and sticky names option.</p>
      <p><strong>Consensus:</strong> Set the frequency threshold for consensus base calling.</p>
      <p><strong>Search:</strong> Enter a motif and choose a highlight color.</p>
      <p><strong>Actions:</strong> All sequence and column manipulation tools are here.</p>
      <h3>Keyboard Shortcuts</h3>
      <ul>
        <li>Ctrl+R: Reverse Complement</li>
        <li>Ctrl+Shift+C: Copy Selected</li>
        <li>Ctrl+Del: Delete Selected</li>
        <li>Ctrl+Z: Undo</li>
        <li>Ctrl+Up: Move Up</li>
        <li>Ctrl+Down: Move Down</li>
        <li>Ctrl+Home: Move to Top</li>
        <li>Ctrl+End: Move to Bottom</li>
        <li>Ctrl+B: Consensus Below</li>
        <li>Ctrl+U: Duplicate</li>
        <li>Ctrl+T: New Tab</li>
        <li>Ctrl+A: Select All</li>
        <li>Ctrl+Shift+V: Copy Columns</li>
        <li>Ctrl+Shift+D: Delete Columns</li>
        <li>Ctrl+Shift+R: Realign Block</li>
        <li>Ctrl+S: Save Preset</li>
        <li>Ctrl+O: Load Preset</li>
        <li>Ctrl+I: Program Info</li>
        <li>Ctrl+H: Hide Menu</li>
        <li>Ctrl+F: Find Motif</li>
        <li>Ctrl+Shift+F: Clear Last Search</li>
        <li>Ctrl+Alt+F: Clear All Searches</li>
        <li>Ctrl+Shift+K: Copy Consensus</li>
        <li>Ctrl+Shift+J: Copy Selected Consensus</li>
        <li>Ctrl+-: Zoom Out</li>
        <li>Ctrl++: Zoom In</li>
      </ul>
    </div>
  </div>
  <div id="alignmentContainer">Paste MSF or FASTA into the box and click Load, or drop a file.</div>
  <div id="statusMessage"></div>
  <script>
    // STATE OBJECT
    const state = {
      seqs: [],
      selectedRows: new Set(),
      selectedColumns: new Set(),
      selectedNucs: new Map(),
      pendingNucStart: null,
      lastSelectedIndex: null,
      consensusSeq: '',
      deletedHistory: [],
      currentFilename: '',
      searchHistory: [],
      isDragging: false,
      dragStartRow: null,
      dragStartCol: null,
      dragMode: null,
      ctrlPressed: false,
      altPressed: false,
      lastAction: null,
      draggingGroup: null,
      slideDragStartX: null,
      slideDragStartPos: null,
      slideSeqIndex: null
    };
    // DOM ELEMENTS
    const el = id => document.getElementById(id);
    const dropZone = el('dropZone');
    const fastaInput = el('fastaInput');
    const alignmentContainer = el('alignmentContainer');
    const tooltip = el('tooltip');
    const statusMessage = el('statusMessage');
    const minimizeBar = el('minimizeBar');
    const infoModal = el('infoModal');
    // UTILITY FUNCTIONS
    function showMessage(msg, duration = 2000) {
      statusMessage.textContent = msg;
      statusMessage.style.display = 'block';
      setTimeout(() => {
        statusMessage.style.display = 'none';
      }, duration);
    }
    function updateSliderBackground(slider) {
      const value = (slider.value - slider.min) / (slider.max - slider.min) * 100;
      slider.style.setProperty('--slider-value', value + '%');
    }
    function toggleStickyNames() {
      const sticky = el('stickyNames').checked;
      document.querySelectorAll('.seq-name').forEach(name => {
        name.classList.toggle('static', !sticky);
      });
      alignmentContainer.offsetHeight; // Force reflow
    }
    function calculateGaplessPositions(sequence) {
      const positions = [];
      let gaplessCount = 0;
      for (let i = 0; i < sequence.length; i++) {
        const char = sequence[i];
        if (char !== '-' && char !== '.') {
          gaplessCount++;
        }
        positions.push(gaplessCount);
      }
      return positions;
    }
    function reverseComplement(seq) {
      const complement = {
        'A':'T','T':'A','C':'G','G':'C','N':'N','-':'-','.':'.',
        'U':'A','R':'Y','Y':'R','M':'K','K':'M','S':'S','W':'W','H':'D','B':'V','V':'B','D':'H'
      };
      return seq.split('').reverse().map(b => complement[b] || 'N').join('');
    }
    // PARSING FUNCTIONS
    function parseFasta(text) {
      const lines = text.trim().split(/\r?\n/);
      const seqs = [];
      let seq = '', header = '';
      try {
        for (let line of lines) {
          line = line.trim();
          if (!line) continue;
          if (line.startsWith('>')) {
            if (seq) {
              const cleanHeader = header.replace(/^>/, '').trim();
              const displayHeader = cleanHeader.split(' ')[0] || 'unnamed';
              let processedSeq = seq.toUpperCase().replace(/[^ACGTUNRYMKSWHBVD\.\-]/g, 'N');
              processedSeq = processedSeq.replace(/\./g, '-');
              const gaplessPositions = calculateGaplessPositions(processedSeq);
              seqs.push({
                header: displayHeader,
                fullHeader: cleanHeader,
                seq: processedSeq,
                gaplessPositions: gaplessPositions
              });
              seq = '';
            }
            header = line;
          } else {
            seq += line.replace(/[^A-Za-z\.\-]/g, '');
          }
        }
        if (header && seq) {
          const cleanHeader = header.replace(/^>/, '').trim();
          const displayHeader = cleanHeader.split(' ')[0] || 'unnamed';
          let processedSeq = seq.toUpperCase().replace(/[^ACGTUNRYMKSWHBVD\.\-]/g, 'N');
          processedSeq = processedSeq.replace(/\./g, '-');
          const gaplessPositions = calculateGaplessPositions(processedSeq);
          seqs.push({
            header: displayHeader,
            fullHeader: cleanHeader,
            seq: processedSeq,
            gaplessPositions: gaplessPositions
          });
        }
      } catch (err) {
        console.error('Error in parseFasta:', err);
        return null;
      }
      return seqs.length ? seqs : null;
    }
    function parseMsf(text) {
      const lines = text.trim().split(/\r?\n/);
      let i = 0;
      let isNucleic = true;
      let maxLen = 0;
      const seqMap = {};
      let names = [];
      // Find MSF header line
      const headerIndex = lines.findIndex(l => l.includes('MSF:') && l.includes('Check:'));
      if (headerIndex !== -1) {
        i = headerIndex;
        const headerLine = lines[headerIndex].trim();
        if (headerLine.includes('Type: P')) {
          isNucleic = false;
        } else if (headerLine.includes('Type: N')) {
          isNucleic = true;
        }
        i += 1; // Start after header
      } else {
        i = 0;
      }
      // Collect names from Name: lines before //
      while (i < lines.length) {
        let line = lines[i].trim();
        if (line === '//') {
          i += 1;
          break;
        }
        if (line.startsWith('Name:')) {
          const parts = line.split(/\s+/);
          let name = '';
          let j = 1; // after 'Name:'
          while (j < parts.length && !parts[j].startsWith('Len:')) {
            name += (name ? ' ' : '') + parts[j];
            j++;
          }
          if (name) {
            names.push(name);
          }
        }
        i += 1;
      }
      // Parse alignment blocks
      while (i < lines.length) {
        let line = lines[i].trim();
        if (!line) {
          i += 1;
          continue;
        }
        // Skip position lines like "1 50"
        if (/^\d+\s+\d+$/.test(line)) {
          i += 1;
          continue;
        }
        let foundName = null;
        for (let n of names) {
          if (line.startsWith(n)) {
            foundName = n;
            let seqPart = line.substring(n.length).trim();
            let blockSeq = seqPart.replace(/\s+/g, '').replace(/~/g, '-');
            if (!seqMap[foundName]) {
              seqMap[foundName] = { header: foundName, fullHeader: foundName, seq: '' };
            }
            const seqObj = seqMap[foundName];
            seqObj.seq += blockSeq;
            if (seqObj.seq.length > maxLen) maxLen = seqObj.seq.length;
            break;
          }
        }
        i += 1;
      }
      const seqs = [];
      for (let name of names) {
        if (seqMap[name]) {
          let seqObj = seqMap[name];
          let processedSeq;
          if (isNucleic) {
            processedSeq = seqObj.seq.toUpperCase().replace(/[^ACGTUNRYMKSWHBVD\.\-]/g, 'N');
          } else {
            processedSeq = seqObj.seq.toUpperCase().replace(/[^A-Z\.\-]/g, 'X');
          }
          processedSeq = processedSeq.replace(/\./g, '-');
          while (processedSeq.length < maxLen) {
            processedSeq += '-';
          }
          const gaplessPositions = calculateGaplessPositions(processedSeq);
          const displayHeader = name.split(' ')[0] || 'unnamed';
          seqs.push({
            header: displayHeader,
            fullHeader: name,
            seq: processedSeq,
            gaplessPositions: gaplessPositions
          });
        }
      }
      return seqs.length ? seqs : null;
    }
    // VALIDATION FUNCTIONS
    function validateThresholds() {
      const b = parseInt(el('blackSlider').value);
      const d = parseInt(el('darkSlider').value);
      const l = parseInt(el('lightSlider').value);
      if (b < d) {
        el('darkSlider').value = el('darkInput').value = b;
        showMessage("Dark threshold adjusted to match Black threshold", 3000);
      }
      if (d < l) {
        el('lightSlider').value = el('lightInput').value = d;
        showMessage("Light threshold adjusted to match Dark threshold", 3000);
      }
      ['blackSlider', 'darkSlider', 'lightSlider'].forEach(id => updateSliderBackground(el(id)));
    }
    // RENDERING FUNCTIONS
    function renderAlignment() {
      if (!state.seqs || state.seqs.length === 0) {
        alignmentContainer.innerHTML = '<div style="padding:20px; color:#666; font-style:italic;">No sequences loaded. Paste FASTA/MSF and click Load.</div>';
        return;
      }
      alignmentContainer.innerHTML = '';
      const nameLengthSlider = el('nameLengthSlider');
      const nameLengthInput = el('nameLengthInput');
      const maxNameLen = Math.max(...state.seqs.map(s => s.header.length), 5);
      nameLengthSlider.max = maxNameLen;
      nameLengthInput.max = maxNameLen;
      nameLengthSlider.value = Math.min(parseInt(nameLengthSlider.value), maxNameLen);
      nameLengthInput.value = nameLengthSlider.value;
      const nameLen = parseInt(nameLengthSlider.value);
      document.documentElement.style.setProperty('--nameLen', nameLen);
      const useBlocks = el('modeBlocks').checked;
      const blockWidth = parseInt(el('blockSizeSlider').value);
      const len = Math.max(...state.seqs.map(s => s.seq.length));
      const blackThresh = parseInt(el('blackSlider').value) / 100;
      const darkThresh = parseInt(el('darkSlider').value) / 100;
      const lightThresh = parseInt(el('lightSlider').value) / 100;
      const enableBlack = el('enableBlack').checked;
      const enableDark = el('enableDark').checked;
      const enableLight = el('enableLight').checked;
      const stickyNames = el('stickyNames').checked;
      const standard = new Set(['A', 'C', 'G', 'T', 'U', 'N', '-', '.']);
      const ambiguous = new Set(['R','Y','M','K','S','W','H','B','V','D']);
      const ambiguousMap = {
        'A,G': 'R', 'G,A': 'R',
        'C,T': 'Y', 'T,C': 'Y',
        'A,C': 'M', 'C,A': 'M',
        'G,T': 'K', 'T,G': 'K',
        'C,G': 'S', 'G,C': 'S',
        'A,T': 'W', 'T,A': 'W',
        'A,C,T': 'H', 'A,T,C': 'H', 'C,A,T': 'H', 'C,T,A': 'H', 'T,A,C': 'H', 'T,C,A': 'H',
        'G,C,T': 'B', 'G,T,C': 'B', 'C,G,T': 'B', 'C,T,G': 'B', 'T,G,C': 'B', 'T,C,G': 'B',
        'A,G,T': 'D', 'A,T,G': 'D', 'G,A,T': 'D', 'G,T,A': 'D', 'T,A,G': 'D', 'T,G,A': 'D',
        'A,C,G': 'V', 'A,G,C': 'V', 'C,A,G': 'V', 'C,G,A': 'V', 'G,A,C': 'V', 'G,C,A': 'V'
      };
      const showConsensus = el('showConsensus').checked;
      const consType = document.querySelector('input[name="consensusType"]:checked').value;
      const threshold = parseInt(el('consensusThreshold').value) / 100;
      let consensus = [];
      if (showConsensus) {
        for (let pos = 0; pos < len; pos++) {
          const col = state.seqs.map(s => s.seq[pos] || '-');
          const nonGapCol = col.filter(b => b !== '-' && b !== '.');
          if (nonGapCol.length === 0) {
            consensus.push('-');
            continue;
          }
          const counts = {};
          nonGapCol.forEach(b => counts[b] = (counts[b] || 0) + 1);
          const maxCount = Math.max(...Object.values(counts));
          const maxBases = Object.keys(counts).filter(b => counts[b] === maxCount);
          const freq = maxCount / col.length;
          if (freq < threshold) {
            consensus.push('-');
            continue;
          }
          if (consType === 'ambiguous') {
            if (maxBases.length > 1) {
              const standardBases = maxBases.filter(b => ['A', 'C', 'G', 'T'].includes(b));
              if (standardBases.length >= 2) {
                const key = standardBases.sort().join(',');
                consensus.push(ambiguousMap[key] || '-');
              } else if (maxBases.length === 1) {
                consensus.push(maxBases[0]);
              } else {
                consensus.push('-');
              }
            } else {
              consensus.push(maxBases[0]);
            }
          } else {
            if (maxBases.length === 1 && !ambiguous.has(maxBases[0])) {
              consensus.push(maxBases[0]);
            } else {
              const normalBases = ['A', 'C', 'G', 'T'].filter(b => counts[b]);
              if (normalBases.length > 0) {
                const maxNormalCount = Math.max(...normalBases.map(b => counts[b] || 0));
                const maxNormalBases = normalBases.filter(b => (counts[b] || 0) === maxNormalCount);
                consensus.push(maxNormalBases[0]);
              } else {
                consensus.push('-');
              }
            }
          }
        }
      }
      state.consensusSeq = consensus.join('').replace(/-/g, '');
      const consensusPosition = document.querySelector('input[name="consensusPosition"]:checked')?.value || 'bottom';
      if (useBlocks) {
        for (let start = 0; start < len; start += blockWidth) {
          const end = Math.min(start + blockWidth, len);
          const blockDiv = document.createElement('div');
          blockDiv.className = 'block-block';
          const sep = document.createElement('div');
          sep.className = 'block-sep';
          sep.textContent = `--- ${start + 1}-${end} ---`;
          blockDiv.appendChild(sep);
          if (showConsensus && consensusPosition === 'top') {
            addConsensusLine(blockDiv, consensus, start, end, nameLen, stickyNames);
          }
          for (let i = 0; i < state.seqs.length; i++) {
            const lineDiv = createSequenceLine(i, start, end, nameLen, stickyNames, standard, ambiguous, blackThresh, darkThresh, lightThresh, enableBlack, enableDark, enableLight);
            blockDiv.appendChild(lineDiv);
          }
          if (showConsensus && consensusPosition === 'bottom') {
            addConsensusLine(blockDiv, consensus, start, end, nameLen, stickyNames);
          }
          alignmentContainer.appendChild(blockDiv);
        }
      } else {
        if (showConsensus && consensusPosition === 'top') {
          addConsensusLine(alignmentContainer, consensus, 0, len, nameLen, stickyNames);
        }
        for (let i = 0; i < state.seqs.length; i++) {
          const lineDiv = createSequenceLine(i, 0, len, nameLen, stickyNames, standard, ambiguous, blackThresh, darkThresh, lightThresh, enableBlack, enableDark, enableLight);
          alignmentContainer.appendChild(lineDiv);
        }
        if (showConsensus && consensusPosition === 'bottom') {
          addConsensusLine(alignmentContainer, consensus, 0, len, nameLen, stickyNames);
        }
      }
      setTimeout(() => toggleStickyNames(), 0);
      ['blackSlider', 'darkSlider', 'lightSlider', 'nameLengthSlider', 'zoomSlider', 'blockSizeSlider', 'consensusThreshold', 'groupConsensusThreshold'].forEach(id => {
        updateSliderBackground(el(id));
      });
      updateRowSelections();
      updateColumnSelections();
      // Re-attach drag listeners for sliding
      document.querySelectorAll('.seq-data').forEach(dataSpan => {
        dataSpan.addEventListener('mousedown', handleSlideStart);
      });
    }
    function createSequenceLine(index, start, end, nameLen, stickyNames, standard, ambiguous, blackThresh, darkThresh, lightThresh, enableBlack, enableDark, enableLight) {
      const lineDiv = document.createElement('div');
      lineDiv.className = 'seq-line';
      lineDiv.dataset.seqIndex = index;
      const nameSpan = document.createElement('div');
      nameSpan.className = `seq-name ${stickyNames ? '' : 'static'}`;
      nameSpan.title = state.seqs[index].fullHeader;
      nameSpan.textContent = state.seqs[index].header.substring(0, nameLen);
      nameSpan.draggable = true;
      nameSpan.addEventListener('dragstart', handleDragStart);
      nameSpan.addEventListener('dragend', handleDragEnd);
      // 👇 CLICK NAME → COPY NAME (no selection toggle)
      nameSpan.addEventListener('click', (e) => {
        if (e.ctrlKey || e.metaKey || e.shiftKey) return; // let mousedown handle selection
        navigator.clipboard.writeText(state.seqs[index].header).then(() => {
          showMessage(`Copied: ${state.seqs[index].header}`, 1500);
        }).catch(err => {
          console.error('Copy failed:', err);
          showMessage("Failed to copy name.", 2000);
        });
        e.preventDefault();
      });
      nameSpan.addEventListener('dblclick', () => {
        const input = document.createElement('input');
        input.type = 'text';
        input.value = state.seqs[index].header;
        input.style.width = `${nameSpan.offsetWidth}px`;
        input.style.fontSize = getComputedStyle(nameSpan).fontSize;
        input.style.fontFamily = getComputedStyle(nameSpan).fontFamily;
        input.style.padding = '0';
        input.style.border = '1px solid #ccc';
        nameSpan.innerHTML = '';
        nameSpan.appendChild(input);
        input.focus();
        input.select();
        const save = () => {
          const newName = input.value.trim();
          if (newName && newName !== state.seqs[index].header) {
            state.deletedHistory.push({
              type: 'rename',
              seqs: JSON.parse(JSON.stringify(state.seqs)),
              selectedRows: new Set(state.selectedRows),
              selectedColumns: new Set(state.selectedColumns)
            });
            state.seqs[index].header = newName;
            state.seqs[index].fullHeader = newName;
            renderAlignment();
            showMessage("Sequence renamed!", 2000);
          } else {
            renderAlignment();
          }
        };
        input.addEventListener('blur', save);
        input.addEventListener('keydown', (e) => {
          if (e.key === 'Enter') {
            save();
          } else if (e.key === 'Escape') {
            renderAlignment();
          }
        });
        // Add outside click handler for faster exit
        const handleOutsideClick = (ev) => {
          if (!nameSpan.contains(ev.target)) {
            save();
            document.removeEventListener('click', handleOutsideClick);
          }
        };
        setTimeout(() => document.addEventListener('click', handleOutsideClick), 0);
      });
      lineDiv.addEventListener('dragover', (e) => e.preventDefault());
      lineDiv.addEventListener('drop', handleDrop);
      lineDiv.appendChild(nameSpan);
      const dataSpan = document.createElement('div');
      dataSpan.className = 'seq-data';
      // 👇 NO ACTION on plain click — only Ctrl+Click for selection
      dataSpan.addEventListener('click', (e) => {
        if (e.ctrlKey || e.metaKey) return; // handled by mousedown
        // 👉 Do nothing on single click — no copy, no selection
      });
      for (let pos = start; pos < end; pos++) {
        const base = state.seqs[index].seq[pos] || '-';
        const gaplessPos = state.seqs[index].gaplessPositions[pos];
        let cls = 'other';
        let baseClass = '';
        if (!standard.has(base) && !ambiguous.has(base)) {
          baseClass = 'artifact';
        } else if (ambiguous.has(base)) {
          baseClass = 'ambiguous';
        }
        const col = state.seqs.map(s => s.seq[pos] || '-');
        const nonGapCol = col.filter(b => b !== '-' && b !== '.');
        if (nonGapCol.length > 0) {
          const counts = {};
          nonGapCol.forEach(b => counts[b] = (counts[b] || 0) + 1);
          const maxCount = Math.max(...Object.values(counts), 0);
          const consensusBases = new Set(Object.keys(counts).filter(b => counts[b] === maxCount));
          const denominator = document.querySelector('input[name="shadeMode"]:checked').value === 'all' ? state.seqs.length : nonGapCol.length;
          const conservation = maxCount / denominator;
          if (base !== '-' && base !== '.' && consensusBases.has(base)) {
            if (enableBlack && conservation >= blackThresh) cls = 'black';
            else if (enableDark && conservation >= darkThresh) cls = 'dark';
            else if (enableLight && conservation >= lightThresh) cls = 'light';
          } else if (base === '-' || base === '.') {
            cls = 'gap';
          }
        } else {
          cls = 'gap';
        }
        const newClass = `${cls} ${baseClass}`.trim();
        const span = document.createElement('span');
        span.className = newClass;
        span.textContent = base;
        span.dataset.pos = pos;
        if (state.selectedNucs.get(index)?.has(pos)) {
          span.classList.add('nuc-selected');
          span.addEventListener('mouseover', (e) => {
            tooltip.style.display = 'block';
            tooltip.textContent = `Copy`;
            tooltip.style.left = (e.pageX + 10) + 'px';
            tooltip.style.top = (e.pageY - 20) + 'px';
          });
          span.addEventListener('mouseout', () => {
            tooltip.style.display = 'none';
          });
          span.addEventListener('click', (e) => {
            e.stopPropagation();
            copySelected();
          });
        }
        if (base !== '-' && base !== '.') {
          const currentGaplessPos = gaplessPos;
          span.addEventListener('mouseover', (e) => {
            tooltip.style.display = 'block';
            tooltip.textContent = `${state.seqs[index].header}: ${currentGaplessPos}`;
            tooltip.style.left = (e.pageX + 10) + 'px';
            tooltip.style.top = (e.pageY - 20) + 'px';
          });
          span.addEventListener('mouseout', () => {
            tooltip.style.display = 'none';
          });
        } else {
          span.title = 'Gap';
        }
        if (state.selectedColumns.has(pos)) {
          span.classList.add('column-selected');
        }
        dataSpan.appendChild(span);
      }
      lineDiv.appendChild(dataSpan);
      if (state.selectedRows.has(index)) {
        lineDiv.classList.add('selected');
      }
      return lineDiv;
    }
    function addConsensusLine(parent, consensus, start, end, nameLen, stickyNames) {
      const consLine = document.createElement('div');
      consLine.className = 'seq-line consensus-line';
      const consName = document.createElement('div');
      consName.className = `seq-name ${stickyNames ? '' : 'static'}`;
      consName.textContent = 'Consensus';
      consLine.appendChild(consName);
      const dataSpan = document.createElement('div');
      dataSpan.className = 'seq-data';
      for (let pos = start; pos < end; pos++) {
        const base = pos < consensus.length ? consensus[pos] : '-';
        let baseClass = '';
        if (!['A','C','G','T','U','N','-','.'].includes(base)) baseClass = 'artifact';
        else if (['R','Y','M','K','S','W','H','B','V','D'].includes(base)) baseClass = 'ambiguous';
        const span = document.createElement('span');
        span.className = baseClass;
        span.textContent = base;
        dataSpan.appendChild(span);
      }
      consLine.appendChild(dataSpan);
      parent.appendChild(consLine);
    }
    function setZoom(percent) {
      const size = (percent / 100) * 13;
      alignmentContainer.style.fontSize = size + 'px';
      el('zoomVal').textContent = percent + '%';
      updateSliderBackground(el('zoomSlider'));
    }
    function adjustZoom(delta) {
      const slider = el('zoomSlider');
      let value = parseInt(slider.value) + delta;
      value = Math.max(parseInt(slider.min), Math.min(parseInt(slider.max), value));
      slider.value = value;
      setZoom(value);
    }
    function debounce(func, delay) {
      let timer;
      return () => {
        clearTimeout(timer);
        timer = setTimeout(func, delay);
      };
    }
    const debounceRender = debounce(renderAlignment, 50);
    // CORE FUNCTIONS
    function parseAndRender(isFromDrop = false) {
      showMessage("Parsing file...", 0);
      const inputText = fastaInput.value.trim();
      if (!inputText) {
        alignmentContainer.innerHTML = '<div>Paste MSF or FASTA into the box and click Load, or drop a file.</div>';
        statusMessage.style.display = 'none';
        return;
      }
      try {
        let parsed;
        if (state.currentFilename.toLowerCase().endsWith('.msf') || isFromDrop || (inputText.includes('MSF:') && inputText.includes('Check:')) || inputText.includes('!!AA_MULTIPLE_ALIGNMENT') || inputText.includes('!!NA_MULTIPLE_ALIGNMENT')) {
          parsed = parseMsf(inputText);
          if (!parsed) {
            showMessage("MSF parsing failed, trying FASTA...", 2000);
            parsed = parseFasta(inputText);
          }
        } else {
          parsed = parseFasta(inputText);
        }
        if (!parsed) throw new Error("No valid sequences found");
        state.seqs = parsed;
        state.selectedRows.clear();
        state.selectedColumns.clear();
        state.selectedNucs.clear();
        state.pendingNucStart = null;
        state.lastSelectedIndex = null;
        if (!isFromDrop) {
          state.currentFilename = 'Clipboard';
        }
        el('filenameInfo').textContent = `Source: ${state.currentFilename}`;
        renderAlignment();
        showMessage("File loaded successfully!", 2000);
      } catch (e) {
        console.error("Error in parseAndRender:", e);
        alignmentContainer.innerHTML = `<div class="error-message">❌ ${e.message}</div>`;
        showMessage(`Error: ${e.message}`, 5000);
      }
    }
    function onModeChange() {
      const container = el('blockSizeContainer');
      if (container) {
        container.style.display = el('modeBlocks').checked ? 'flex' : 'none';
      }
      renderAlignment();
    }
    function onShadeModeChange() {
      validateThresholds();
      debounceRender();
    }
    // DRAG AND DROP HANDLERS
    function handleDragStart(e) {
      const row = e.target.closest('.seq-line');
      if (row.classList.contains('consensus-line')) return;
      const index = parseInt(row.dataset.seqIndex);
      if (state.selectedRows.has(index)) {
        state.draggingGroup = Array.from(state.selectedRows).sort((a, b) => a - b);
      } else {
        e.preventDefault();
        return;
      }
      e.dataTransfer.setData('text/plain', '');
      e.dataTransfer.effectAllowed = 'move';
    }
    function handleDragEnd(e) {
      state.draggingGroup = null;
    }
    function handleDrop(e) {
      e.preventDefault();
      if (!state.draggingGroup) return;
      const targetRow = e.target.closest('.seq-line');
      if (!targetRow || targetRow.classList.contains('consensus-line')) return;
      const targetIndex = parseInt(targetRow.dataset.seqIndex);
      const rect = targetRow.getBoundingClientRect();
      const y = e.clientY - rect.top;
      const insertAfter = y > rect.height / 2;
      const groupIndices = state.draggingGroup;
      if (groupIndices.includes(targetIndex)) return;
      state.deletedHistory.push({
        type: 'order',
        seqs: JSON.parse(JSON.stringify(state.seqs)),
        selectedRows: new Set(state.selectedRows),
        selectedColumns: new Set(state.selectedColumns)
      });
      const newSeqs = [...state.seqs];
      const group = groupIndices.map(i => newSeqs[i]);
      for (let j = groupIndices.length - 1; j >= 0; j--) {
        newSeqs.splice(groupIndices[j], 1);
      }
      let insertPos = targetIndex - groupIndices.filter(i => i < targetIndex).length;
      if (insertAfter) insertPos += 1;
      newSeqs.splice(insertPos, 0, ...group);
      state.seqs = newSeqs;
      state.selectedRows.clear();
      for (let k = 0; k < group.length; k++) {
        state.selectedRows.add(insertPos + k);
      }
      state.draggingGroup = null;
      renderAlignment();
      showMessage("Sequences reordered!", 2000);
    }
    // EVENT HANDLERS
    function handleMouseDown(e) {
      if (e.button !== 0) return;
      const row = e.target.closest('.seq-line');
      if (!row || row.classList.contains('consensus-line')) return;
      const index = parseInt(row.dataset.seqIndex);
      const name = e.target.closest('.seq-name');
      const span = e.target.closest('.seq-data span');
      if (name) {
        if (e.ctrlKey || e.metaKey) {
          state.isDragging = true;
          state.dragStartRow = index;
          state.dragMode = 'row';
          if (state.selectedRows.has(index)) {
            state.selectedRows.delete(index);
          } else {
            state.selectedRows.add(index);
          }
          state.lastSelectedIndex = index;
          updateRowSelections();
          e.preventDefault();
        } else if (e.shiftKey && state.lastSelectedIndex !== null) {
          const start = Math.min(state.lastSelectedIndex, index);
          const end = Math.max(state.lastSelectedIndex, index);
          for (let i = start; i <= end; i++) {
            state.selectedRows.add(i);
          }
          updateRowSelections();
          e.preventDefault();
        }
        // 👉 No else clause — click without Ctrl/Shift copies name (handled in nameSpan.click)
      } else if (span && (e.ctrlKey || e.metaKey) && !e.altKey) {
        const pos = parseInt(span.dataset.pos);
        if (isNaN(pos)) return;
        if (state.pendingNucStart === null) {
          state.selectedNucs.clear();
          state.pendingNucStart = {row: index, pos: pos};
        } else if (state.pendingNucStart.row === index) {
          const startPos = Math.min(state.pendingNucStart.pos, pos);
          const endPos = Math.max(state.pendingNucStart.pos, pos);
          let rowSet = new Set();
          for (let p = startPos; p <= endPos; p++) {
            rowSet.add(p);
          }
          state.selectedNucs.set(index, rowSet);
          state.pendingNucStart = null;
          debounceRender();
        } else {
          state.pendingNucStart = null;
        }
        e.preventDefault();
      } else if (span && (e.ctrlKey || e.metaKey) && e.altKey) {
        const pos = parseInt(span.dataset.pos);
        if (isNaN(pos)) return;
        state.isDragging = true;
        state.dragStartCol = pos;
        state.dragMode = 'col';
        if (state.selectedColumns.has(pos)) {
          state.selectedColumns.delete(pos);
        } else {
          state.selectedColumns.add(pos);
        }
        updateColumnSelections();
        e.preventDefault();
      }
      // 👉 No handler for plain click on span — do nothing
    }
    function handleMouseMove(e) {
      if (!state.isDragging) return;
      if (state.dragMode === 'row') {
        const row = e.target.closest('.seq-line');
        if (row) {
          const index = parseInt(row.dataset.seqIndex);
          if (index !== undefined) {
            const start = Math.min(state.dragStartRow, index);
            const end = Math.max(state.dragStartRow, index);
            for (let i = start; i <= end; i++) {
              state.selectedRows.add(i);
            }
            updateRowSelections();
          }
        }
      } else if (state.dragMode === 'col') {
        const span = e.target.closest('.seq-data span');
        if (span) {
          const pos = parseInt(span.dataset.pos);
          if (isNaN(pos)) return;
          const start = Math.min(state.dragStartCol, pos);
          const end = Math.max(state.dragStartCol, pos);
          for (let p = start; p <= end; p++) {
            state.selectedColumns.add(p);
          }
          updateColumnSelections();
        }
      } else if (state.dragMode === 'nuc') {
        const span = e.target.closest('.seq-data span');
        if (span) {
          const pos = parseInt(span.dataset.pos);
          if (isNaN(pos)) return;
          const currentIndex = parseInt(span.closest('.seq-line').dataset.seqIndex);
          if (state.pendingNucStart.row === currentIndex && pos !== state.pendingNucStart.pos) {
            const startPos = Math.min(state.pendingNucStart.pos, pos);
            const endPos = Math.max(state.pendingNucStart.pos, pos);
            let rowSet = new Set();
            for (let p = startPos; p <= endPos; p++) {
              rowSet.add(p);
            }
            state.selectedNucs.set(currentIndex, rowSet);
            debounceRender();
          }
        }
      }
      e.preventDefault();
    }
    function handleMouseUp() {
      if (state.dragMode === 'nuc' && state.pendingNucStart) {
        state.pendingNucStart = null;
      }
      state.isDragging = false;
      state.dragStartRow = null;
      state.dragStartCol = null;
      state.dragMode = null;
    }
    function handleKeyDown(e) {
      if (e.ctrlKey || e.metaKey) {
        state.ctrlPressed = true;
      }
      if (e.altKey) {
        state.altPressed = true;
      }
      if ((e.ctrlKey || e.metaKey) && e.key.toLowerCase() === 'c') {
        copySelected();
        e.preventDefault();
      }
      if (e.ctrlKey || e.metaKey) {
        switch (e.key.toLowerCase()) {
          case 'r':
            reverseComplementSelected();
            e.preventDefault();
            break;
          case 'del':
            deleteSelected();
            e.preventDefault();
            break;
          case 'z':
            undoDelete();
            e.preventDefault();
            break;
          case 'b':
            insertGroupConsensus();
            e.preventDefault();
            break;
          case 'u':
            duplicateSelected();
            e.preventDefault();
            break;
          case 't':
            openSelectedInNewTab();
            e.preventDefault();
            break;
          case 'a':
            selectAllSequences();
            e.preventDefault();
            break;
          case 's':
            if (e.shiftKey) {
              savePreset();
              e.preventDefault();
            }
            break;
          case 'o':
            loadPreset();
            e.preventDefault();
            break;
          case 'i':
            openInfoModal();
            e.preventDefault();
            break;
          case 'h':
            minimizeMenu();
            e.preventDefault();
            break;
          case 'f':
            if (e.shiftKey) {
              clearLastSearch();
            } else if (e.altKey) {
              clearAllSearches();
            } else {
              searchMotif();
            }
            e.preventDefault();
            break;
          case 'k':
            if (e.shiftKey) {
              copyConsensus();
            }
            e.preventDefault();
            break;
          case 'j':
            if (e.shiftKey) {
              copySelectedConsensus();
            }
            e.preventDefault();
            break;
          case 'v':
            if (e.shiftKey) {
              copySelectedColumns();
            }
            e.preventDefault();
            break;
          case 'd':
            if (e.shiftKey) {
              deleteSelectedColumns();
            }
            e.preventDefault();
            break;
          case '+':
            adjustZoom(10);
            e.preventDefault();
            break;
          case '-':
            adjustZoom(-10);
            e.preventDefault();
            break;
        }
      }
      if (e.ctrlKey || e.metaKey) {
        if (e.key === 'ArrowUp') {
          moveSelectedUp();
          e.preventDefault();
        } else if (e.key === 'ArrowDown') {
          moveSelectedDown();
          e.preventDefault();
        } else if (e.key === 'Home') {
          moveSelectedToTop();
          e.preventDefault();
        } else if (e.key === 'End') {
          moveSelectedToBottom();
          e.preventDefault();
        }
      }
    }
    function handleKeyUp(e) {
      if (!e.ctrlKey && !e.metaKey) {
        state.ctrlPressed = false;
      }
      if (!e.altKey) {
        state.altPressed = false;
      }
    }
    // ACTION FUNCTIONS
    function reverseComplementSelected() {
      if (state.selectedRows.size === 0) {
        showMessage("Select sequences (Ctrl+click) to RevComp.", 3000);
        return;
      }
      state.deletedHistory.push({
        type: 'revcomp',
        seqs: JSON.parse(JSON.stringify(state.seqs)),
        selectedRows: new Set(state.selectedRows),
        selectedColumns: new Set(state.selectedColumns)
      });
      for (const i of state.selectedRows) {
        if (i < state.seqs.length) {
          state.seqs[i] = {
            ...state.seqs[i],
            seq: reverseComplement(state.seqs[i].seq)
          };
          state.seqs[i].gaplessPositions = calculateGaplessPositions(state.seqs[i].seq);
        }
      }
      state.lastAction = 'revcomp';
      renderAlignment();
      showMessage("Reverse complement applied!", 2000);
    }
    function deleteSelected() {
      if (state.selectedRows.size === 0) {
        showMessage("No sequences selected for deletion.", 3000);
        return;
      }
      if (state.seqs.length === 1) {
        showMessage("Cannot delete the last sequence.", 3000);
        return;
      }
      if (confirm(`Delete ${state.selectedRows.size} sequence(s)?`)) {
        state.deletedHistory.push({
          type: 'delete',
          seqs: JSON.parse(JSON.stringify(state.seqs)),
          selectedRows: new Set(state.selectedRows),
          selectedColumns: new Set(state.selectedColumns)
        });
        const indicesToDelete = Array.from(state.selectedRows).sort((a,b)=>b-a);
        for (const index of indicesToDelete) {
          if (index < state.seqs.length) {
            state.seqs.splice(index, 1);
          }
        }
        state.selectedRows.clear();
        state.lastSelectedIndex = null;
        state.lastAction = 'delete';
        renderAlignment();
        showMessage("Sequences deleted!", 2000);
      }
    }
    function undoDelete() {
      if (state.deletedHistory.length === 0) {
        showMessage("Nothing to undo.", 3000);
        return;
      }
      const last = state.deletedHistory.pop();
      state.seqs = last.seqs;
      state.selectedRows = last.selectedRows;
      if (last.selectedColumns) {
        state.selectedColumns = last.selectedColumns;
      }
      state.lastAction = null;
      renderAlignment();
      showMessage("Undo completed!", 2000);
    }
    function copySelected() {
      let nucText = '';
      for (let [i, posSet] of state.selectedNucs.entries()) {
        if (posSet.size === 0) continue;
        const s = state.seqs[i];
        const poss = Array.from(posSet).sort((a, b) => a - b);
        let start = poss[0], end = poss[0];
        let ranges = [];
        for (let j = 1; j < poss.length; j++) {
          if (poss[j] === end + 1) {
            end = poss[j];
          } else {
            ranges.push([start, end]);
            start = end = poss[j];
          }
        }
        ranges.push([start, end]);
        for (let [st, en] of ranges) {
          const sub = s.seq.slice(st, en + 1);
          nucText += sub + '\n';
        }
      }
      if (nucText) {
        navigator.clipboard.writeText(nucText.trim()).then(() => {
          showMessage("Selected nucleotides copied!", 2000);
        }).catch(err => {
          console.error('Copy failed:', err);
          showMessage("Failed to copy. Check console.", 5000);
        });
        return;
      }
      // 👇 Removed "No sequence selected" message — silent if nothing to copy
      if (state.selectedRows.size === 0) {
        return;
      }
      const fasta = Array.from(state.selectedRows).sort((a,b) => a - b).map(i => {
        const s = state.seqs[i];
        return `>${s.fullHeader || s.header}\n${s.seq}`;
      }).join('\n');
      navigator.clipboard.writeText(fasta).then(() => {
        showMessage("Selected sequences copied as FASTA!", 2000);
      }).catch(err => {
        console.error('Copy failed:', err);
        showMessage("Failed to copy. Check console.", 5000);
      });
    }
    function copyPlainSingle(index) {
      const s = state.seqs[index];
      navigator.clipboard.writeText(s.seq).then(() => {
        showMessage("Sequence copied as plain text!", 2000);
      }).catch(err => {
        console.error('Copy failed:', err);
        showMessage("Failed to copy. Check console.", 5000);
      });
    }
    function copyConsensus() {
      if (!state.consensusSeq) {
        showMessage("No consensus available to copy.", 3000);
        return;
      }
      const fasta = `>Consensus\n${state.consensusSeq}`;
      navigator.clipboard.writeText(fasta).then(() => {
        showMessage("Consensus copied as FASTA!", 2000);
      }).catch(err => {
        console.error('Copy failed:', err);
        showMessage("Failed to copy. Check console.", 5000);
      });
    }
    function copySelectedConsensus() {
      if (state.selectedRows.size < 2) {
        showMessage("Select at least 2 sequences to compute consensus.", 3000);
        return;
      }
      const selectedSeqs = Array.from(state.selectedRows).map(i => state.seqs[i].seq);
      const len = Math.max(...selectedSeqs.map(s => s.length));
      const threshold = parseInt(el('consensusThreshold').value) / 100;
      let cons = '';
      for (let pos = 0; pos < len; pos++) {
        const col = selectedSeqs.map(s => s[pos] || '-').filter(b => b !== '-' && b !== '.');
        if (col.length === 0) continue;
        const counts = {};
        col.forEach(b => counts[b] = (counts[b] || 0) + 1);
        const maxBase = Object.keys(counts).reduce((a, b) => counts[a] > counts[b] ? a : b, '');
        const freq = counts[maxBase] / col.length;
        if (freq >= threshold) {
          cons += maxBase;
        }
      }
      const fasta = `>Selected_Consensus\n${cons}`;
      navigator.clipboard.writeText(fasta).then(() => {
        showMessage("Selected sequences consensus copied as FASTA!", 2000);
      }).catch(err => {
        console.error('Copy failed:', err);
        showMessage("Failed to copy. Check console.", 5000);
      });
    }
    function copySelectedColumns() {
      if (state.selectedColumns.size === 0) {
        showMessage("No columns selected to copy.", 3000);
        return;
      }
      const cols = Array.from(state.selectedColumns).sort((a,b) => a - b);
      const fasta = state.seqs.map(s => {
        let seq = '';
        for (const pos of cols) {
          seq += s.seq[pos] || '-';
        }
        return `>${s.fullHeader || s.header}\n${seq}`;
      }).join('\n');
      navigator.clipboard.writeText(fasta).then(() => {
        showMessage("Selected columns copied as FASTA!", 2000);
      }).catch(err => {
        console.error('Copy failed:', err);
        showMessage("Failed to copy.", 5000);
      });
    }
    function deleteSelectedColumns() {
      if (state.selectedColumns.size === 0) {
        showMessage("No columns selected for deletion.", 3000);
        return;
      }
      if (confirm(`Delete ${state.selectedColumns.size} column(s)?`)) {
        state.deletedHistory.push({
          type: 'deleteColumns',
          seqs: JSON.parse(JSON.stringify(state.seqs)),
          selectedRows: new Set(state.selectedRows),
          selectedColumns: new Set(state.selectedColumns)
        });
        const colsToDelete = Array.from(state.selectedColumns).sort((a,b) => b - a);
        state.seqs = state.seqs.map(s => {
          let seq = s.seq.split('');
          for (const pos of colsToDelete) {
            if (pos < seq.length) seq.splice(pos, 1);
          }
          s.gaplessPositions = calculateGaplessPositions(seq.join(''));
          return { ...s, seq: seq.join('') };
        });
        state.selectedColumns.clear();
        state.lastAction = 'deleteColumns';
        renderAlignment();
        showMessage("Columns deleted!", 2000);
      }
    }
    function selectAllSequences() {
      if (state.selectedRows.size === state.seqs.length) {
        state.selectedRows.clear();
        showMessage("All sequences deselected.", 2000);
      } else {
        state.selectedRows.clear();
        for (let i = 0; i < state.seqs.length; i++) {
          state.selectedRows.add(i);
        }
        showMessage("All sequences selected.", 2000);
      }
      updateRowSelections();
    }
    function moveSelectedUp() {
      if (state.selectedRows.size === 0) return;
      state.deletedHistory.push({
        type: 'order',
        seqs: JSON.parse(JSON.stringify(state.seqs)),
        selectedRows: new Set(state.selectedRows),
        selectedColumns: new Set(state.selectedColumns)
      });
      const indices = Array.from(state.selectedRows).sort((a, b) => a - b);
      if (indices[0] === 0) return;
      const newSeqs = [...state.seqs];
      const group = indices.map(i => newSeqs[i]);
      for (let j = indices.length - 1; j >= 0; j--) {
        newSeqs.splice(indices[j], 1);
      }
      const insertPos = indices[0] - 1;
      newSeqs.splice(insertPos, 0, ...group);
      state.seqs = newSeqs;
      state.selectedRows.clear();
      for (let k = 0; k < indices.length; k++) {
        state.selectedRows.add(insertPos + k);
      }
      renderAlignment();
      showMessage("Sequences moved up!", 2000);
    }
    function moveSelectedDown() {
      if (state.selectedRows.size === 0) return;
      state.deletedHistory.push({
        type: 'order',
        seqs: JSON.parse(JSON.stringify(state.seqs)),
        selectedRows: new Set(state.selectedRows),
        selectedColumns: new Set(state.selectedColumns)
      });
      const indices = Array.from(state.selectedRows).sort((a, b) => a - b);
      if (indices[indices.length - 1] === state.seqs.length - 1) return;
      const newSeqs = [...state.seqs];
      const group = indices.map(i => newSeqs[i]);
      for (let j = indices.length - 1; j >= 0; j--) {
        newSeqs.splice(indices[j], 1);
      }
      const insertPos = indices[indices.length - 1] - indices.length + 2;
      newSeqs.splice(insertPos, 0, ...group);
      state.seqs = newSeqs;
      state.selectedRows.clear();
      for (let k = 0; k < indices.length; k++) {
        state.selectedRows.add(insertPos + k);
      }
      renderAlignment();
      showMessage("Sequences moved down!", 2000);
    }
    function moveSelectedToTop() {
      if (state.selectedRows.size === 0) return;
      state.deletedHistory.push({
        type: 'order',
        seqs: JSON.parse(JSON.stringify(state.seqs)),
        selectedRows: new Set(state.selectedRows),
        selectedColumns: new Set(state.selectedColumns)
      });
      const indices = Array.from(state.selectedRows).sort((a, b) => a - b);
      const newSeqs = [...state.seqs];
      const group = indices.map(i => newSeqs[i]);
      for (let j = indices.length - 1; j >= 0; j--) {
        newSeqs.splice(indices[j], 1);
      }
      newSeqs.unshift(...group);
      state.seqs = newSeqs;
      state.selectedRows.clear();
      for (let k = 0; k < group.length; k++) {
        state.selectedRows.add(k);
      }
      renderAlignment();
      showMessage("Sequences moved to top!", 2000);
    }
    function moveSelectedToBottom() {
      if (state.selectedRows.size === 0) return;
      state.deletedHistory.push({
        type: 'order',
        seqs: JSON.parse(JSON.stringify(state.seqs)),
        selectedRows: new Set(state.selectedRows),
        selectedColumns: new Set(state.selectedColumns)
      });
      const indices = Array.from(state.selectedRows).sort((a, b) => a - b);
      const newSeqs = [...state.seqs];
      const group = indices.map(i => newSeqs[i]);
      for (let j = indices.length - 1; j >= 0; j--) {
        newSeqs.splice(indices[j], 1);
      }
      newSeqs.push(...group);
      state.seqs = newSeqs;
      state.selectedRows.clear();
      const newLen = state.seqs.length;
      for (let k = 0; k < group.length; k++) {
        state.selectedRows.add(newLen - group.length + k);
      }
      renderAlignment();
      showMessage("Sequences moved to bottom!", 2000);
    }
    function insertGroupConsensus() {
      if (state.selectedRows.size < 2) {
        showMessage("Select at least 2 sequences to compute group consensus.", 3000);
        return;
      }
      const indices = Array.from(state.selectedRows).sort((a, b) => a - b);
      const selectedSeqs = indices.map(i => state.seqs[i].seq);
      const len = Math.max(...selectedSeqs.map(s => s.length));
      const threshold = parseInt(el('groupConsensusThreshold').value) / 100;
      let cons = '';
      for (let pos = 0; pos < len; pos++) {
        const col = selectedSeqs.map(s => s[pos] || '-').filter(b => b !== '-' && b !== '.');
        if (col.length === 0) {
          cons += '-';
          continue;
        }
        const counts = {};
        col.forEach(b => counts[b] = (counts[b] || 0) + 1);
        const maxBase = Object.keys(counts).reduce((a, b) => counts[a] > counts[b] ? a : b, '');
        const freq = counts[maxBase] / col.length;
        cons += (freq >= threshold) ? maxBase : '-';
      }
      const consObj = {
        header: 'Group_Consensus',
        fullHeader: 'Consensus of selected group',
        seq: cons,
        gaplessPositions: calculateGaplessPositions(cons)
      };
      const insertPos = indices[indices.length - 1] + 1;
      state.seqs.splice(insertPos, 0, consObj);
      renderAlignment();
      showMessage("Group consensus inserted!", 2000);
    }
    function duplicateSelected() {
      if (state.selectedRows.size === 0) return;
      const indices = Array.from(state.selectedRows).sort((a, b) => a - b);
      const copies = indices.map(i => ({...state.seqs[i], header: state.seqs[i].header + '_copy'}));
      state.seqs.push(...copies);
      renderAlignment();
      showMessage("Selected sequences duplicated!", 2000);
    }
    function openSelectedInNewTab() {
      if (state.selectedRows.size === 0) {
        showMessage("No sequences selected.", 3000);
        return;
      }
      const fasta = Array.from(state.selectedRows).sort((a,b) => a - b).map(i => {
        const s = state.seqs[i];
        return `>${s.fullHeader || s.header}\n${s.seq}`;
      }).join('\n');
      const blob = new Blob([fasta], {type: 'text/plain'});
      const url = URL.createObjectURL(blob);
      const newWindow = window.open();
      newWindow.document.write('<textarea style="width:100%;height:100%;">' + fasta + '</textarea>');
      newWindow.document.title = 'Selected Sequences';
      newWindow.document.close();
      showMessage("Selected sequences opened in new tab!", 2000);
    }
    function savePreset() {
      const preset = {
        black: el('blackSlider').value,
        dark: el('darkSlider').value,
        light: el('lightSlider').value,
        zoom: el('zoomSlider').value,
        mode: el('modeBlocks').checked ? 'blocks' : 'single',
        blockSize: el('blockSizeSlider').value,
        nameLen: el('nameLengthSlider').value,
        consensusThreshold: el('consensusThreshold').value,
        groupConsensusThreshold: el('groupConsensusThreshold').value,
        consensusType: document.querySelector('input[name="consensusType"]:checked').value,
        showConsensus: el('showConsensus').checked,
        consensusPosition: document.querySelector('input[name="consensusPosition"]:checked').value,
        shadeMode: document.querySelector('input[name="shadeMode"]:checked').value,
        enableBlack: el('enableBlack').checked,
        enableDark: el('enableDark').checked,
        enableLight: el('enableLight').checked,
        stickyNames: el('stickyNames').checked
      };
      localStorage.setItem('qwen_msa_viewer_preset_v44', JSON.stringify(preset));
      showMessage("Preset saved!", 2000);
    }
    function loadPreset() {
      const saved = localStorage.getItem('qwen_msa_viewer_preset_v44');
      if (!saved) {
        showMessage("No saved preset found.", 3000);
        return;
      }
      const p = JSON.parse(saved);
      ['black','dark','light','zoom','blockSize','nameLen','consensusThreshold', 'groupConsensusThreshold'].forEach(k => {
        el(k + 'Slider').value = p[k];
        const inputElement = el(k + 'Input');
        if (inputElement) inputElement.value = p[k];
        updateSliderBackground(el(k + 'Slider'));
      });
      setZoom(p.zoom);
      el('modeBlocks').checked = p.mode === 'blocks';
      el('modeSingle').checked = p.mode !== 'blocks';
      el('stickyNames').checked = p.stickyNames !== undefined ? p.stickyNames : true;
      onModeChange();
      toggleStickyNames();
      document.querySelector(`input[name="consensusType"][value="${p.consensusType}"]`).checked = true;
      el('showConsensus').checked = p.showConsensus;
      document.querySelector(`input[name="consensusPosition"][value="${p.consensusPosition}"]`).checked = true;
      document.querySelector(`input[name="shadeMode"][value="${p.shadeMode}"]`).checked = true;
      el('enableBlack').checked = p.enableBlack;
      el('enableDark').checked = p.enableDark;
      el('enableLight').checked = p.enableLight;
      renderAlignment();
      showMessage("Preset loaded!", 2000);
    }
    function minimizeMenu() {
      const controls = el('controls');
      const filenameInfo = el('filenameInfo');
      minimizeBar.parentNode.insertBefore(filenameInfo, minimizeBar.nextSibling);
      filenameInfo.style.position = 'sticky';
      filenameInfo.style.top = '0px';
      filenameInfo.style.zIndex = '98';
      controls.style.display = 'none';
      minimizeBar.style.display = 'block';
    }
    function expandMenu() {
      minimizeBar.style.display = 'none';
      const controls = el('controls');
      const filenameInfo = el('filenameInfo');
      controls.appendChild(filenameInfo);
      filenameInfo.style.position = '';
      filenameInfo.style.top = '';
      filenameInfo.style.zIndex = '';
      controls.style.display = 'grid';
    }
    function searchMotif() {
      const motif = el('searchInput').value.trim().toUpperCase();
      if (!motif) return;
      const color = el('searchColor').value;
      const className = 'search-hit-' + Math.random().toString(36).substring(2, 12) + btoa(motif).replace(/=/g, '').substring(0, 5);
      state.searchHistory = state.searchHistory.filter(item => {
        if (item.motif === motif) {
          document.querySelectorAll(`.${item.className}`).forEach(span => {
            span.classList.remove(item.className);
          });
          document.querySelector(`style[data-motif="${item.motif}"]`)?.remove();
          return false;
        }
        return true;
      });
      const style = document.createElement('style');
      style.textContent = `.${className} { background-color: ${color} !important; color: black !important; font-weight: bold; }`;
      style.setAttribute('data-motif', motif);
      document.head.appendChild(style);
      state.searchHistory.push({ motif, color, className });
      document.querySelectorAll('.seq-line:not(.consensus-line)').forEach(row => {
        const index = parseInt(row.dataset.seqIndex);
        if (index >= state.seqs.length || index < 0) return;
        const seq = state.seqs[index].seq;
        const degapped = seq.replace(/[-.]/g, '');
        const dataSpan = row.querySelector('.seq-data');
        const spans = Array.from(dataSpan.children);
        const nonGapSpans = spans.filter(s => s.textContent !== '-' && s.textContent !== '.');
        for (let seqPos = 0; seqPos <= degapped.length - motif.length; seqPos++) {
          const sub = degapped.substring(seqPos, seqPos + motif.length);
          if (sub === motif) {
            for (let i = 0; i < motif.length; i++) {
              const child = nonGapSpans[seqPos + i];
              if (child) child.classList.add(className);
            }
          }
        }
      });
      el('searchInput').value = '';
      showMessage(`Found "${motif}"!`, 2000);
    }
    function clearLastSearch() {
      if (state.searchHistory.length === 0) {
        showMessage("No searches to clear.", 3000);
        return;
      }
      const last = state.searchHistory.pop();
      document.querySelectorAll(`.${last.className}`).forEach(span => span.classList.remove(last.className));
      document.querySelector(`style[data-motif="${last.motif}"]`)?.remove();
      showMessage("Last search cleared!", 2000);
    }
    function clearAllSearches() {
      state.searchHistory.forEach(item => {
        document.querySelectorAll(`.${item.className}`).forEach(span => {
          span.classList.remove(item.className);
        });
        document.querySelector(`style[data-motif="${item.motif}"]`)?.remove();
      });
      state.searchHistory = [];
      showMessage("All searches cleared!", 2000);
    }
    function openInfoModal() {
      infoModal.style.display = 'block';
    }
    function closeInfoModal() {
      infoModal.style.display = 'none';
    }
    function realignSelectedBlock() {
      showMessage("Realign Block not implemented yet.", 3000);
    }
    function copySequences(gapped, isFasta, index) {
      let indices = Array.from(state.selectedRows).sort((a,b)=>a-b);
      if (indices.length === 0) {
        indices = [index];
      }
      let text = '';
      if (isFasta) {
        text = indices.map(i => {
          let seq = state.seqs[i].seq;
          if (!gapped) seq = seq.replace(/[-.]/g, '');
          return `>${state.seqs[i].fullHeader || state.seqs[i].header}\n${seq}`;
        }).join('\n');
      } else {
        text = indices.map(i => {
          let seq = state.seqs[i].seq;
          if (!gapped) seq = seq.replace(/[-.]/g, '');
          return seq;
        }).join('\n');
      }
      navigator.clipboard.writeText(text).then(() => {
        const count = indices.length;
        const type = isFasta ? 'FASTA' : 'plain text';
        const gapType = gapped ? 'gapped' : 'ungapped';
        showMessage(`${count > 1 ? 'Selected sequences' : 'Sequence'} copied as ${type} (${gapType})!`, 2000);
      }).catch(err => {
        console.error('Copy failed:', err);
        showMessage("Failed to copy.", 5000);
      });
    }
    function deleteSequence(index) {
      if (state.seqs.length === 1) {
        showMessage("Cannot delete the last sequence.", 3000);
        return;
      }
      if (confirm('Delete this sequence?')) {
        state.deletedHistory.push({
          type: 'delete',
          seqs: JSON.parse(JSON.stringify(state.seqs)),
          selectedRows: new Set(),
          selectedColumns: new Set(state.selectedColumns)
        });
        state.seqs.splice(index, 1);
        state.selectedRows.clear();
        renderAlignment();
        showMessage("Sequence deleted!", 2000);
      }
    }
    let contextMenu = null;
    function showContextMenu(e, index) {
      if (contextMenu) {
        contextMenu.remove();
      }
      contextMenu = document.createElement('div');
      contextMenu.className = 'context-menu';
      contextMenu.style.left = `${e.pageX}px`;
      contextMenu.style.top = `${e.pageY}px`;
      const copyFastaGapped = document.createElement('div');
      copyFastaGapped.textContent = 'Copy as FASTA gapped';
      copyFastaGapped.addEventListener('click', () => {
        copySequences(true, true, index);
        contextMenu.remove();
      });
      const copyFastaUngapped = document.createElement('div');
      copyFastaUngapped.textContent = 'Copy as FASTA ungapped';
      copyFastaUngapped.addEventListener('click', () => {
        copySequences(false, true, index);
        contextMenu.remove();
      });
      const copyPlainGapped = document.createElement('div');
      copyPlainGapped.textContent = 'Copy as plain text gapped';
      copyPlainGapped.addEventListener('click', () => {
        copySequences(true, false, index);
        contextMenu.remove();
      });
      const copyPlainUngapped = document.createElement('div');
      copyPlainUngapped.textContent = 'Copy as plain text ungapped';
      copyPlainUngapped.addEventListener('click', () => {
        copySequences(false, false, index);
        contextMenu.remove();
      });
      contextMenu.appendChild(copyFastaGapped);
      contextMenu.appendChild(copyFastaUngapped);
      contextMenu.appendChild(copyPlainGapped);
      contextMenu.appendChild(copyPlainUngapped);
      const deleteItem = document.createElement('div');
      deleteItem.textContent = state.selectedRows.size > 1 ? 'Delete selected' : 'Delete sequence';
      deleteItem.addEventListener('click', () => {
        if (state.selectedRows.size > 1) {
          deleteSelected();
        } else {
          deleteSequence(index);
        }
        contextMenu.remove();
      });
      contextMenu.appendChild(deleteItem);
      if (state.selectedRows.size <= 1) {
        const renameItem = document.createElement('div');
        renameItem.textContent = 'Rename sequence';
        renameItem.addEventListener('click', () => {
          const input = document.createElement('input');
          input.type = 'text';
          input.value = state.seqs[index].header;
          input.style.width = `${e.target.offsetWidth}px`;
          input.style.fontSize = getComputedStyle(e.target).fontSize;
          input.style.fontFamily = getComputedStyle(e.target).fontFamily;
          input.style.padding = '0';
          input.style.border = '1px solid #ccc';
          e.target.innerHTML = '';
          e.target.appendChild(input);
          input.focus();
          input.select();
          const save = () => {
            const newName = input.value.trim();
            if (newName && newName !== state.seqs[index].header) {
              state.deletedHistory.push({
                type: 'rename',
                seqs: JSON.parse(JSON.stringify(state.seqs)),
                selectedRows: new Set(),
                selectedColumns: new Set(state.selectedColumns)
              });
              state.seqs[index].header = newName;
              state.seqs[index].fullHeader = newName;
              renderAlignment();
              showMessage("Sequence renamed!", 2000);
            } else {
              renderAlignment();
            }
          };
          input.addEventListener('blur', save);
          input.addEventListener('keydown', (ev) => {
            if (ev.key === 'Enter') {
              save();
            } else if (ev.key === 'Escape') {
              renderAlignment();
            }
          });
          contextMenu.remove();
        });
        contextMenu.appendChild(renameItem);
      }
      const clearSelItem = document.createElement('div');
      clearSelItem.textContent = 'Clear selection';
      clearSelItem.addEventListener('click', () => {
        state.selectedRows.clear();
        state.selectedColumns.clear();
        state.selectedNucs.clear();
        updateRowSelections();
        updateColumnSelections();
        renderAlignment();
        contextMenu.remove();
      });
      contextMenu.appendChild(clearSelItem);
      // Add insert/remove single gap if on span
      if (e.target.tagName === 'SPAN' && e.target.parentNode.className === 'seq-data') {
        const pos = parseInt(e.target.dataset.pos);
        const insertGapItem = document.createElement('div');
        insertGapItem.textContent = 'Insert Single Gap Here';
        insertGapItem.addEventListener('click', () => {
          insertSingleGap(index, pos);
          contextMenu.remove();
        });
        contextMenu.appendChild(insertGapItem);
        const removeGapItem = document.createElement('div');
        removeGapItem.textContent = 'Remove Single Gap Here';
        removeGapItem.addEventListener('click', () => {
          removeSingleGap(index, pos);
          contextMenu.remove();
        });
        contextMenu.appendChild(removeGapItem);
      }
      document.body.appendChild(contextMenu);
    }
    function updateRowSelections() {
      document.querySelectorAll('.seq-line.selected').forEach(line => line.classList.remove('selected'));
      state.selectedRows.forEach(index => {
        document.querySelectorAll(`.seq-line[data-seq-index="${index}"]`).forEach(line => line.classList.add('selected'));
      });
    }
    function updateColumnSelections() {
      document.querySelectorAll('.seq-data span.column-selected').forEach(span => span.classList.remove('column-selected'));
      state.selectedColumns.forEach(pos => {
        document.querySelectorAll(`.seq-data span[data-pos="${pos}"]`).forEach(span => span.classList.add('column-selected'));
      });
    }
    // EVENT LISTENERS
    document.addEventListener('DOMContentLoaded', () => {
      dropZone.addEventListener('dragover', (e) => {
        e.preventDefault();
        dropZone.style.borderColor = 'var(--dropzone-hover-border)';
      });
      dropZone.addEventListener('dragleave', () => {
        dropZone.style.borderColor = 'var(--dropzone-border)';
      });
      dropZone.addEventListener('drop', (e) => {
        e.preventDefault();
        dropZone.style.borderColor = 'var(--dropzone-border)';
        const file = e.dataTransfer.files[0];
        if (!file) return;
        state.currentFilename = file.name;
        const reader = new FileReader();
        reader.onload = function(e) {
          fastaInput.value = e.target.result;
          parseAndRender(true);
        };
        reader.onerror = () => {
          alignmentContainer.innerHTML = '<div class="error-message">❌ Error reading file.</div>';
          showMessage("Error reading file.", 5000);
        };
        reader.readAsText(file);
      });
      el('loadButton').addEventListener('click', () => parseAndRender(false));
      el('reverseComplementButton').addEventListener('click', reverseComplementSelected);
      el('copySelectedButton').addEventListener('click', copySelected);
      el('deleteSelectedButton').addEventListener('click', deleteSelected);
      el('undoButton').addEventListener('click', undoDelete);
      el('moveUpButton').addEventListener('click', moveSelectedUp);
      el('moveDownButton').addEventListener('click', moveSelectedDown);
      el('moveToTopButton').addEventListener('click', moveSelectedToTop);
      el('moveToBottomButton').addEventListener('click', moveSelectedToBottom);
      el('insertGroupConsensusButton').addEventListener('click', insertGroupConsensus);
      el('duplicateButton').addEventListener('click', duplicateSelected);
      el('openInNewTabButton').addEventListener('click', openSelectedInNewTab);
      el('selectAllButton').addEventListener('click', selectAllSequences);
      el('copyColumnsButton').addEventListener('click', copySelectedColumns);
      el('deleteColumnsButton').addEventListener('click', deleteSelectedColumns);
      el('realignBlockButton').addEventListener('click', realignSelectedBlock);
      el('savePresetButton').addEventListener('click', savePreset);
      el('loadPresetButton').addEventListener('click', loadPreset);
      el('infoButton').addEventListener('click', openInfoModal);
      el('minimizeBtn').addEventListener('click', minimizeMenu);
      minimizeBar.addEventListener('click', expandMenu);
      el('zoomInButton').addEventListener('click', () => adjustZoom(10));
      el('zoomOutButton').addEventListener('click', () => adjustZoom(-10));
      el('searchButton').addEventListener('click', searchMotif);
      el('clearLastSearchButton').addEventListener('click', clearLastSearch);
      el('clearAllSearchesButton').addEventListener('click', clearAllSearches);
      el('copyConsensusButton').addEventListener('click', copyConsensus);
      el('copySelectedConsensusButton').addEventListener('click', copySelectedConsensus);
      el('removeGapColumnsButton').addEventListener('click', removeGapColumns);
      el('insertGapColumnAllButton').addEventListener('click', () => insertGapColumn(true));
      el('insertGapColumnExceptButton').addEventListener('click', () => insertGapColumn(false));
      ['blackSlider', 'darkSlider', 'lightSlider', 'nameLengthSlider', 'zoomSlider', 'blockSizeSlider', 'consensusThreshold', 'groupConsensusThreshold'].forEach(id => {
        el(id).addEventListener('input', () => {
          const inputId = id.replace('Slider', 'Input');
          if (el(inputId)) el(inputId).value = el(id).value;
          if (id === 'zoomSlider') {
            setZoom(el(id).value);
          } else {
            debounceRender();
          }
          updateSliderBackground(el(id));
          if (id.includes('Slider') && (id.includes('black') || id.includes('dark') || id.includes('light'))) {
            validateThresholds();
          }
        });
      });
      ['blackInput', 'darkInput', 'lightInput', 'nameLengthInput', 'blockSizeInput', 'consensusThresholdInput', 'groupConsensusThresholdInput'].forEach(id => {
        el(id).addEventListener('input', () => {
          const sliderId = id.replace('Input', 'Slider');
          el(sliderId).value = el(id).value;
          if (sliderId === 'zoomSlider') {
            setZoom(el(id).value);
          } else {
            debounceRender();
          }
          updateSliderBackground(el(sliderId));
          if (id.includes('Input') && (id.includes('black') || id.includes('dark') || id.includes('light'))) {
            validateThresholds();
          }
        });
      });
      document.querySelectorAll('input[name="shadeMode"]').forEach(radio => {
        radio.addEventListener('change', onShadeModeChange);
      });
      document.querySelectorAll('input[name="mode"]').forEach(radio => {
        radio.addEventListener('change', onModeChange);
      });
      document.querySelectorAll('input[name="consensusType"]').forEach(radio => {
        radio.addEventListener('change', debounceRender);
      });
      document.querySelectorAll('input[name="consensusPosition"]').forEach(radio => {
        radio.addEventListener('change', debounceRender);
      });
      el('enableBlack').addEventListener('change', debounceRender);
      el('enableDark').addEventListener('change', debounceRender);
      el('enableLight').addEventListener('change', debounceRender);
      el('showConsensus').addEventListener('change', debounceRender);
      el('stickyNames').addEventListener('change', toggleStickyNames);
      alignmentContainer.addEventListener('mousedown', handleMouseDown);
      alignmentContainer.addEventListener('mousemove', handleMouseMove);
      document.addEventListener('mouseup', handleMouseUp);
      document.addEventListener('keydown', handleKeyDown);
      document.addEventListener('keyup', handleKeyUp);
      document.addEventListener('click', (event) => {
        if (event.target === infoModal) {
          closeInfoModal();
        }
      });
      alignmentContainer.addEventListener('contextmenu', (e) => {
        const name = e.target.closest('.seq-name');
        if (name) {
          e.preventDefault();
          const row = e.target.closest('.seq-line');
          const index = parseInt(row.dataset.seqIndex);
          showContextMenu(e, index);
        } else if (e.target.tagName === 'SPAN' && e.target.parentNode.className === 'seq-data') {
          e.preventDefault();
          const row = e.target.closest('.seq-line');
          const index = parseInt(row.dataset.seqIndex);
          showContextMenu(e, index);
        }
      });
      document.addEventListener('click', () => {
        if (contextMenu) {
          contextMenu.remove();
          contextMenu = null;
        }
      });
      alignmentContainer.addEventListener('scroll', () => {
        document.querySelectorAll('.seq-name').forEach(name => {
          name.style.display = 'none';
          name.offsetHeight;
          name.style.display = '';
        });
      });
      el('modeBlocks').checked = true;
      el('modeSingle').checked = false;
      document.querySelector('input[name="consensusPosition"][value="bottom"]').checked = true;
      onModeChange();
      toggleStickyNames();
      ['blackSlider', 'darkSlider', 'lightSlider', 'nameLengthSlider', 'zoomSlider', 'blockSizeSlider', 'consensusThreshold', 'groupConsensusThreshold'].forEach(id => {
        updateSliderBackground(el(id));
      });
    });
    // NEW EDITING FUNCTIONS
    function removeGapColumns() {
      if (state.seqs.length === 0) return;
      const len = state.seqs[0].seq.length;
      const colsToRemove = [];
      for (let pos = 0; pos < len; pos++) {
        if (state.seqs.every(s => s.seq[pos] === '-' || s.seq[pos] === '.')) {
          colsToRemove.push(pos);
        }
      }
      if (colsToRemove.length === 0) {
        showMessage("No gap-only columns to remove.", 2000);
        return;
      }
      state.deletedHistory.push({
        type: 'removeGaps',
        seqs: JSON.parse(JSON.stringify(state.seqs)),
        removedCols: colsToRemove
      });
      state.seqs.forEach(s => {
        let seqArr = s.seq.split('');
        colsToRemove.sort((a, b) => b - a).forEach(pos => seqArr.splice(pos, 1));
        s.seq = seqArr.join('');
        s.gaplessPositions = calculateGaplessPositions(s.seq);
      });
      renderAlignment();
      showMessage(`${colsToRemove.length} gap columns removed!`, 2000);
    }
    function insertGapColumn(all = true) {
      if (state.selectedColumns.size === 0) {
        showMessage("Select a column position by Ctrl+Alt+click on a nucleotide to insert gap there.", 5000);
        return;
      }
      const pos = Math.min(...state.selectedColumns);
      state.deletedHistory.push({
        type: 'insertGap',
        seqs: JSON.parse(JSON.stringify(state.seqs)),
        pos: pos,
        all: all
      });
      state.seqs.forEach((s, i) => {
        if (!all && state.selectedRows.has(i)) return; // Skip selected if not all
        s.seq = s.seq.slice(0, pos) + '-' + s.seq.slice(pos);
        s.gaplessPositions = calculateGaplessPositions(s.seq);
      });
      state.selectedColumns.clear();
      renderAlignment();
      showMessage("Gap column inserted!", 2000);
    }
    function insertSingleGap(rowIndex, pos) {
      const s = state.seqs[rowIndex];
      state.deletedHistory.push({
        type: 'insertSingleGap',
        seqs: JSON.parse(JSON.stringify(state.seqs)),
        rowIndex: rowIndex,
        pos: pos
      });
      s.seq = s.seq.slice(0, pos) + '-' + s.seq.slice(pos);
      s.gaplessPositions = calculateGaplessPositions(s.seq);
      renderAlignment();
      showMessage("Single gap inserted!", 2000);
    }
    function removeSingleGap(rowIndex, pos) {
      const s = state.seqs[rowIndex];
      if (s.seq[pos] !== '-' && s.seq[pos] !== '.') {
        showMessage("Not a gap.", 2000);
        return;
      }
      state.deletedHistory.push({
        type: 'removeSingleGap',
        seqs: JSON.parse(JSON.stringify(state.seqs)),
        rowIndex: rowIndex,
        pos: pos
      });
      s.seq = s.seq.slice(0, pos) + s.seq.slice(pos + 1);
      s.gaplessPositions = calculateGaplessPositions(s.seq);
      renderAlignment();
      showMessage("Single gap removed!", 2000);
    }
    // Slide by dragging seq-data
    function handleSlideStart(e) {
      if (e.button !== 2) return; // Right click only
      e.preventDefault(); // Prevent context menu
      const dataSpan = e.target.closest('.seq-data');
      if (!dataSpan) return;
      const seqIndex = parseInt(dataSpan.parentNode.dataset.seqIndex);
      state.slideSeqIndex = seqIndex;
      state.slideDragStartX = e.clientX;
      document.addEventListener('mousemove', handleSlideMove);
      document.addEventListener('mouseup', handleSlideEnd);
    }
    function handleSlideMove(e) {
      const deltaX = e.clientX - state.slideDragStartX;
      const shift = Math.sign(deltaX) * Math.floor(Math.abs(deltaX) / 20); // Shift every 20px
      if (shift !== 0) {
        shiftSequence(state.slideSeqIndex, shift);
        state.slideDragStartX = e.clientX; // Reset start for next shift
      }
    }
    function handleSlideEnd() {
      document.removeEventListener('mousemove', handleSlideMove);
      document.removeEventListener('mouseup', handleSlideEnd);
      if (state.slideSeqIndex !== null) {
        renderAlignment(); // Re-render to update DOM and reapply sticky
      }
      state.slideSeqIndex = null;
    }
    function getLeadingGaps(seq) {
      let count = 0;
      for (let char of seq) {
        if (char === '-' || char === '.') count++;
        else break;
      }
      return count;
    }
    function getTrailingGaps(seq) {
      let count = 0;
      for (let i = seq.length - 1; i >= 0; i--) {
        if (seq[i] === '-' || seq[i] === '.') count++;
        else break;
      }
      return count;
    }
    function shiftSequence(index, amount) {
      const s = state.seqs[index];
      state.deletedHistory.push({
        type: 'shift',
        seqs: JSON.parse(JSON.stringify(state.seqs)),
        index: index,
        amount: amount
      });
      if (amount > 0) { // right shift
        const maxShift = getTrailingGaps(s.seq);
        if (maxShift === 0) {
          showMessage("Cannot shift right: no trailing gaps.", 2000);
          return;
        }
        amount = Math.min(amount, maxShift);
        s.seq = '-'.repeat(amount) + s.seq.slice(0, -amount);
      } else if (amount < 0) { // left shift
        amount = -amount;
        const maxShift = getLeadingGaps(s.seq);
        if (maxShift === 0) {
          showMessage("Cannot shift left: no leading gaps.", 2000);
          return;
        }
        amount = Math.min(amount, maxShift);
        s.seq = s.seq.slice(amount) + '-'.repeat(amount);
      }
      s.gaplessPositions = calculateGaplessPositions(s.seq);
      renderAlignment();
      showMessage(`Sequence shifted by ${amount}!`, 2000);
    }
  </script>
</body>
</html>
